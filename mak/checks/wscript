from waflib import Utils, ConfigSet
from waflib.Configure import conf
from waflib.TaskGen import feature, before_method, after_method
import os
import sys

USE_LIBRARY_CODE="""
%(include)s
#if defined(_WIN32) && !defined(__clang__)
__declspec(dllexport) int be_test()
{
	return 0;
}
#endif
int main(int argc, char *argv[])
{
	%(function)s
	return 0;
}
"""


USE_SDK_CODE="""
#include <iostream>
#include <cstdlib>
#include <cassert>
#include <stdio.h>

int main(int argc, const char *argv[])
{ return EXIT_SUCCESS; }
"""


@feature("link_library")
@before_method("process_source")
def link_library_test(self):
	def write_test_file(task):
		task.outputs[0].write(task.generator.code)
	bld = self.bld
	bld(rule=write_test_file, target='main.cc', code=self.code)
	bld(features='cxx cxxprogram', source='main.cc', target='app', lib=self.libname, libpath=self.libpath, includes=self.includepath, use=self.use)


@feature("link_framework")
@before_method("process_source")
def link_framework_test(self):
	def write_test_file(task):
		task.outputs[0].write(task.generator.code)
	bld = self.bld
	bld(rule=write_test_file, target='main.cc', code=self.code)
	env = self.env.derive()
	env.detach()
	env.FRAMEWORK = self.frameworks
	env.append_unique('CXXFLAGS', ['-F%s' % f for f in self.frameworks])
	if self.sdk:
		env.append_unique('CXXFLAGS', ['-isysroot', self.sdk])
		env.append_unique('LINKFLAGS', ['-isysroot', self.sdk, '-L%s/usr/lib'%self.sdk])
	if self.version:
		env.append_unique('CXXFLAGS', [self.version])
		env.append_unique('LINKFLAGS', [self.version])
	bld(features='cxx cxxprogram', source='main.cc', target='app', lib=self.libname, libpath=self.libpath, includes=self.includepath, env=env, use=self.use)


@conf
def check_lib(self, libname, var='', libpath=[], includepath=[], includes=[], functions=[], code=USE_LIBRARY_CODE):
	def cut(string):
		if len(string) > 19:
			return string[0:17]+'...'
		else:
			return string
	libname = Utils.to_list(libname)
	if not var: var = libname[0]
	if self.env[var]:
		return
	try:
		self.check(
			compile_filename=[],
			features='link_library',
			msg='check for libraries %s' %cut(','.join(libname)),
			libname=libname,
			libpath=libpath,
			code=code % {
					'include': '\n'.join(['#include <%s>'%i for i in includes]),
					'function': '\n'.join(['(void)&%s;'%f for f in functions])
				},
			includepath=includepath,
			use=['debug'],
			envname=self.env.TOOLCHAIN)
	except self.errors.ConfigurationError:
		pass
	else:
		self.env[var] = libname
		self.detected += libname
	return self.env[var]


@conf
def check_header(self, headername, var='', libpath=[], includepath=[], code=USE_LIBRARY_CODE):
	def cut(string):
		if len(string) > 19:
			return string[0:17]+'...'
		else:
			return string
	headername = Utils.to_list(headername)
	if not var: var = os.path.splitext(headername[0])[0]
	if self.env[var]:
		return
	try:
		self.check(
			compile_filename=[],
			features='link_library',
			msg='check for header %s' %cut(','.join(headername)),
			libname=[],
			libpath=libpath,
			code='\n'.join(["#include <%s>"%h for h in headername]) + '\n' + code,
			includepath=includepath,
			use=['debug'],
			envname=self.env.TOOLCHAIN)
	except self.errors.ConfigurationError as e:
		pass
	else:
		self.env[var] = headername
	return self.env[var]


@conf
def check_framework(self, frameworks, var='', libpath=[], includepath=[], includes=[], functions=[], code=USE_LIBRARY_CODE):
	def cut(string):
		if len(string) > 19:
			return string[0:17]+'...'
		else:
			return string
	frameworks = Utils.to_list(frameworks)
	if not var: var = os.path.splitext(frameworks[0])[0]
	if self.env[var]:
		return
	try:
		self.check(
			compile_filename=[],
			features='link_framework',
			msg='check for framework %s' %cut(','.join(frameworks)),
			libname=[],
			frameworks=frameworks,
			libpath=libpath,
			code=code % {
					'include': '\n'.join(['#include <%s>'%i for i in includes]),
					'function': '\n'.join(['(void)&%s;'%f for f in functions])
				},
			includepath=includepath,
			sdk='',
			version='',
			use=['debug'],
			envname=self.env.TOOLCHAIN)
	except self.errors.ConfigurationError as e:
		pass
	else:
		self.env[var] = frameworks
		self.env.append_unique('XCODE_FRAMEWORKS', frameworks)
		self.detected += frameworks
	return self.env[var]


@conf
def check_sdk(self, compiler, flags, sdk, version, libpath=[], includepath=[], code=USE_SDK_CODE):
	env = ConfigSet.ConfigSet()
	env.CXX = compiler
	env.LINK_CXX = compiler
	env.CXXFLAGS = flags
	env.LINKFLAGS = flags
	env.CXX_TGT_F = ['-c', '-o']
	env.CXXLNK_TGT_F = ['-o']

	self.check(
		env=env,
		compile_filename=[],
		features='link_framework',
		msg='check for SDK %s' %os.path.split(sdk)[1],
		libname=[],
		frameworks=[],
		libpath=libpath,
		code=code,
		includepath=includepath,
		sdk=sdk,
		version=version,
		use=['debug'],
		errmsg='not usable',
		compiler=compiler,
		envname=self.env.TOOLCHAIN)


@conf
def pkg_config(conf, name, var=''):
	if not conf.env.PKG_CONFIG:
		raise WafError('no pkg-config tool found')
	if not var: var = name
	command = [conf.env.PKG_CONFIG, name, '--cflags']
	p = Utils.subprocess.Popen(command, stdin=Utils.subprocess.PIPE, stdout=Utils.subprocess.PIPE)
	out,err = p.communicate()
	if p.returncode != 0:
		if not isinstance(err, str):
			err = err.decode(sys.stdout.encoding or 'iso8859-1')
		raise WafError('could not run %s: %s' % (command, err))
	if not isinstance(out, str):
		out = out.decode(sys.stdout.encoding or 'iso8859-1')
	cflags = out.split()

	command = [conf.env.PKG_CONFIG, name, '--libs']
	p = Utils.subprocess.Popen(command, stdin=Utils.subprocess.PIPE, stdout=Utils.subprocess.PIPE)
	out,err = p.communicate()
	if p.returncode != 0:
		if not isinstance(err, str):
			err = err.decode(sys.stdout.encoding or 'iso8859-1')
		raise WafError('could not run %s: %s' % (command, err))
	if not isinstance(out, str):
		out = out.decode(sys.stdout.encoding or 'iso8859-1')
	libs = out.split()

	conf.env['CFLAGS_%s'%var] = cflags
	conf.env['CXXFLAGS_%s'%var] = cflags
	conf.env['LINKFLAGS_%s'%var] = libs


def configure(conf):
	pass

