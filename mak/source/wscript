import os
from waflib import Task, Options
from waflib.TaskGen import task_gen, taskgen_method, before_method, after_method, feature, extension

@taskgen_method
@feature('*')
@before_method('process_source')
def filter_sources(self):
	self.objc = False
	self.source = self.to_nodes(getattr(self, 'source', []))
	sources = []
	for file in self.source:
		basename,ext = os.path.splitext(file.name)
		add_platform = True
		add_arch = True
		platform = file.name.find('-p=')
		if platform != -1:
			add_platform = False
			platforms = basename[platform+3:].split(',')
			for p in platforms:
				add_platform = add_platform or p in self.env.VALID_PLATFORMS
		arch = file.name.find('-a=')
		if arch != -1:
			add_arch = False
			architectures = basename[arch+3:].split(',')
			for a in architectures:
				add_arch = add_arch or a in self.env.VALID_ARCHITECTURES
		node = file.parent
		while add_platform and add_arch and node and node != self.path:
			if node.name.startswith('platform='):
				add_platform = False
				platforms = node.name[9:].split(',')
				for p in platforms:
					add_platform = add_platform or p in self.env.VALID_PLATFORMS
			elif node.name.startswith('arch='):
				add_arch = False
				architectures = node.name[5:].split(',')
				for a in architectures:
					add_arch = add_arch or a in self.env.VALID_ARCHITECTURES
			elif node.parent.name == 'extra' and node.parent.parent == self.path:
				add_platform = node.name in self.env.VALID_PLATFORMS
			node = node.parent
		if add_platform and add_arch:
			sources.append(file)
			if ext in ['.m', '.mm']:
				self.objc = True
	self.source = sources

@extension('.pkg', '.lua')
def install_data(self, node):
	data_node = self.bld.bugenginenode.make_node('src/%s/data' % self.target.replace('.', '/'))
	self.bld.install_as(os.path.join('build', self.env.TOOLCHAIN, self.env.VARIANT, self.env.DEPLOY_DATADIR, node.path_from(data_node)), node)

@extension('.plist')
def install_plist(self, node):
	self.bld.install_files(os.path.join(self.env.PREFIX, self.bld.optim, self.env.DEPLOY_ROOTDIR), node)

@extension('.dll', '.so')
def install_binary(self, node):
	self.bld.install_files(os.path.join('build', self.env.TOOLCHAIN, self.env.VARIANT, self.env.DEPLOY_RUNBINDIR), node)

def rc_hook(self, node):
	pass

def options(opt):
	pass

def configure(conf):
	conf.load('flex', tooldir=['mak/tools'])
	conf.load('bison', tooldir=['mak/tools'])
	conf.load('data', tooldir=['mak/tools'])

def build(bld):
	if bld.env.PROJECTS:
		if not '.rc' in task_gen.mappings:
			task_gen.mappings['.rc'] = rc_hook


from waflib.Tools import c,cxx

def create_master_file(task):
	with open(task.outputs[0].abspath(), 'w') as f:
		for src in task.inputs:
			f.write('#include "%s"\n' % src.path_from(task.generator.bld.bugenginenode).replace('\\','/'))
def master_sig_deps(task):
	for f in sorted([i.srcpath().encode('utf8') for i in task.inputs]):
		task.m.update(f)
		task.m.update(b';')
MasterTask = Task.task_factory("master", create_master_file, color='CYAN')
MasterTask.sig_explicit_deps = master_sig_deps

@extension('.c', '.m')
def c_hook(self, node):
	if 'master' in self.features and not Options.options.nomaster:
		try:
			mastertask_c = self.mastertasks_c[-1]
			if len(mastertask_c.inputs) <= 20:
				mastertask_c.set_inputs([node])
			else:
				output = self.path.find_or_declare(self.target+'-c-%d-master.%s' % (len(self.mastertasks_c), self.objc and 'm' or 'c'))
				mastertask_c = self.create_task('master', [node], [output])
				self.mastertasks_c.append(mastertask_c)
				self.create_compiled_task('c', output)
		except:
			output = self.path.find_or_declare(self.target+'-c-0-master.%s' % (self.objc and 'm' or 'c'))
			mastertask_c = self.create_task('master', [node], [output])
			self.mastertasks_c = [mastertask_c]
			self.create_compiled_task('c', output)
	else:
		self.create_compiled_task('c', node)

@extension('.cc', '.cxx', '.cpp', '.mm')
def cc_hook(self, node):
	if 'master' in self.features and not Options.options.nomaster:
		if node.name.endswith('-instances.cc'):
			try:
				self.instancetask_cxx.set_inputs([node])
			except:
				output = self.path.find_or_declare(self.target+'-cxx-instances-master.%s' % (self.objc and 'mm' or 'cc'))
				self.instancetask_cxx = self.create_task('master', [node], [output])
				self.create_compiled_task('cxx', output)
		else:
			try:
				mastertask_cxx = self.mastertasks_cxx[-1]
				if len(mastertask_cxx.inputs) <= 20:
					mastertask_cxx.set_inputs([node])
				else:
					output = self.path.find_or_declare(self.target+'-cxx-%d-master.%s' % (len(self.mastertasks_cxx), self.objc and 'mm' or 'cc'))
					mastertask_cxx = self.create_task('master', [node], [output])
					self.mastertasks_cxx.append(mastertask_cxx)
					self.create_compiled_task('cxx', output)
			except:
				output = self.path.find_or_declare(self.target+'-cxx-0-master.%s' % (self.objc and 'mm' or 'cc'))
				mastertask_cxx = self.create_task('master', [node], [output])
				self.mastertasks_cxx = [mastertask_cxx]
				self.create_compiled_task('cxx', output)
	else:
		self.create_compiled_task('cxx', node)
