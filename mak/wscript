#set general options for building

import os
import re
from waflib.TaskGen import taskgen_method,feature,before_method,after_method,extension,before
from waflib import Options,Task,Node,Errors
import mak
from mak import module
from waflib.Logs import pprint
from waflib.Tools import ccroot



def options(opt):
	opt.recurse(os.path.join('host', os.name))
	opt.load('visualstudio netbeans xcode eclipse', tooldir='mak/tools/IDE')
	#opt.load('parallel_debug', tooldir='mak/waflib/extras')
	for l in 'platforms','archs':
		for target in os.listdir(os.path.join('mak', 'target', l)):
			if target not in ['.svn', '.cvs']:
				opt.recurse(os.path.join('target', l, target))
	if os.path.isdir('extra'):
		for f in os.listdir('extra'):
			if f in ['.svn', '.cvs']:
				continue
			if os.path.isdir(os.path.join('extra', f)) and os.path.isfile(os.path.join('extra', f, 'wscript')):
				opt.recurse(os.path.join('..', 'extra', f))
	opt.add_option( '--projects',
					action='store',
					default='',
					dest='projects',
					help='build projects for the selected IDEs')
	opt.add_option( '--toolchains',
					action='store',
					default='',
					dest='toolchains',
					help='build for the selected toolchains')
	opt.add_option( '--master',
					action='store_true',
					default=True,
					dest='master',
					help='build with master files')

def configure(conf):
	conf.mak = os.getcwd() + "/mak"
	conf.env['ARCHITECTURES']	= mak.allarchs

	#conf.load('parallel_debug', tooldir='mak/waflib/extras')
	conf.load('visualstudio netbeans xcode', tooldir='mak/tools/IDE')
	conf.recurse(os.path.join('host', os.name))
	if os.path.isdir('extra'):
		for f in os.listdir('extra'):
			if f in ['.svn', '.cvs']:
				continue
			if os.path.isdir(os.path.join('extra', f)) and os.path.isfile(os.path.join('extra', f, 'wscript')):
				pprint('BLUE', '==================================')
				pprint('BLUE', '= configure for target '+f)
				conf.recurse(os.path.join('..', 'extra', f))
	for platform in os.listdir(os.path.join('mak', 'target', 'platforms')):
		if platform == conf.env.HOST: continue
		if platform not in ['.svn', '.cvs']:
			pprint('BLUE', '==================================')
			pprint('BLUE', '= configure for target '+platform)
			conf.recurse(os.path.join('target', 'platforms', platform))
	pprint('BLUE', '==================================')
	pprint('BLUE', '= configure for target '+conf.env.HOST)
	conf.recurse(os.path.join('target', 'platforms', conf.env.HOST))


	if len(conf.env['BUILD_VARIANTS']) == 0:
		raise SystemExit("no match found : make sure you selected a valid toolchain")
	conf.env['DEFAULT_BUILD_TOOL'] = conf.env['BUILD_VARIANTS'][-1]

	selectedvariants = []
	for optim in mak.alloptims:
		for envname in conf.env['BUILD_VARIANTS']:
			name = optim+'-'+envname
			conf.setenv(name, conf.all_envs[envname])
			conf.env['OPTIMISATION'] = optim
			conf.env['PREFIX'] = os.path.join('build', name)
			selectedvariants.append(name)

	conf.variant = ''
	conf.env['BUILD_VARIANTS'] = selectedvariants
	conf.env['ALL_VARIANTS'] = selectedvariants

	if Options.options.toolchains:
		conf.env['SELECTED_TOOLCHAINS'] = Options.options.toolchains
		selectedtoolchains = [re.compile(selected) for selected in conf.env['SELECTED_TOOLCHAINS'].split(',')]
		allvariants = conf.env['BUILD_VARIANTS']
		selectedvariants = []
		for v in allvariants:
			for e in selectedtoolchains:
				if e.match(v):
					pprint('GREEN', 'selected variant %s for build' % v)
					selectedvariants.append(v)
		if not selectedvariants:
			conf.fatal('No toolchain matches the pattern %s, available : %s' % (Options.options.toolchains,str(allvariants)))
	else:
		conf.env['SELECTED_TOOLCHAINS'] = 'debug-'+conf.env['DEFAULT_BUILD_TOOL']
		pprint('GREEN', 'selected variant %s for build' % str(conf.env['SELECTED_TOOLCHAINS']))
	conf.env.store('.build/be_toolchains.py')

def selectToolchains(ctx):
	if not Options.options.toolchains:
		Options.options.toolchains = ctx.env['SELECTED_TOOLCHAINS']
	selectedtoolchains = [re.compile(selected) for selected in Options.options.toolchains.split(',')]
	selectedvariants = []
	if Options.options.projects:
		ctx.env['PROJECTS'] = Options.options.projects.split(',')
	else:
		allvariants = ctx.env['BUILD_VARIANTS']
		for v in allvariants:
			for e in selectedtoolchains:
				if e.match(v):
					selectedvariants.append(v)
					pprint('GREEN', 'selected variant %s for build' % v)
	ctx.env['BUILD_VARIANTS'] = selectedvariants

def build(bld):
	module.m = {}
	for l in 'platforms','archs':
		for target in os.listdir(os.path.join('mak', 'target', l)):
			if target not in ['.svn', '.cvs']:
				bld.recurse(os.path.join('target', l, target))
	if os.path.isdir('extra'):
		for target in os.listdir(os.path.join('extra')):
			if target not in ['.svn', '.cvs']:
				bld.recurse(os.path.join('..', 'extra', target))
	selectToolchains(bld)
	global builder
	mak.builder = bld

def clean(ctx):
	selectToolchains(ctx)

def install(ctx):
	selectToolchains(ctx)

def uninstall(ctx):
	selectToolchains(ctx)

@extension('.m')
def m_hook(self, node):
	"""Alias .m files to be compiled the same as .c files, gcc will do the right thing."""
	return self.create_compiled_task('c', node)

@extension('.mm')
def mm_hook(self, node):
	"""Alias .mm files to be compiled the same as .cxx files, gcc will do the right thing."""
	return self.create_compiled_task('cxx', node)

@taskgen_method
@feature('c','cxx')
@before_method('process_source')
def filter_sources(self):
	v = self.env
	self.source = self.to_list(self.source)
	rejectedsources = []
	self.allsources = {}
	for source in self.source:
		head,tail = os.path.split(source)
		while tail:
			head,tail = os.path.split(head)
			if tail[0:5] == 'arch=':
				archs=set(tail[5:].split(','))
				if not v['ARCHITECTURE'] in archs:
					try: self.allsources[tail].append(source)
					except KeyError: self.allsources[tail] = [source]
					rejectedsources.append(source)
					continue
			if tail[0:9] == 'platform=':
				platforms=set(tail[9:].split(','))
				if not set(v['PLATFORM']) & platforms:
					try: self.allsources[tail].append(source)
					except KeyError: self.allsources[tail] = [source]
					rejectedsources.append(source)
					continue
	for src in rejectedsources:
		self.source.remove(src)

@feature('c', 'cxx')
@before_method('apply_incpaths')
@after_method('propagate_uselib_vars')
def private_headers(self):
	self.env.append_value('DEFINES', getattr(self, 'private_defines', []))
	self.env.append_value('INCLUDES', ['.']+getattr(self, 'private_includes', []))

@feature('cobjects')
def dummy_cobjects(self):
	pass




def createmasterfile(task):
	f = open(task.outputs[0].abspath(), 'w')
	for src in task.inputs:
		f.write('#include "%s"\n' % src.path_from(task.generator.bld.path).replace('\\','/'))
	f.close()

MasterTask = Task.task_factory("MkMaster", createmasterfile)

@taskgen_method
@feature('master')
@before_method('process_source')
@after_method('filter_sources')
@before('c', 'cxx')
def make_masterfiles(self):
	if not Options.options.master:
		return
	self.originalsources = self.source[:]
	self.originalsources.sort()
	self.mastertasks = []
	self.source = []
	mastertask = None
	cindex	 = 0
	cppindex = 0
	cnumleft = 0
	cppnumleft = 0
	for f in self.originalsources:
		if os.path.splitext(f)[1] not in ['.c', '.C', '.cc', '.cpp', '.cxx', '.hh']:
			self.source.append(f)
			continue
		if os.path.splitext(f)[1] == '.hh':
			self.source.append(f)
			srcnode = self.path.find_resource(f).change_ext('.cc')
		else:
			srcnode = self.path.find_resource(f)
		if os.path.splitext(f)[1] == '.c':
			if cnumleft == 0:
				cnumleft = 30
				masterfile = self.target+'-c-master%d.c' % cindex
				cindex = cindex + 1
				self.source.append(masterfile)
				node = self.path.find_or_declare(masterfile)
				mastertask = self.create_task("MkMaster", [], node)
				self.mastertasks.append(mastertask)
			cnumleft = cnumleft - 1
			mastertask.set_inputs(srcnode)
		else:
			if cppnumleft == 0:
				cppnumleft = 30
				masterfile = self.target+'-cpp-master%d.cpp' % cppindex
				cppindex = cppindex + 1
				self.source.append(masterfile)
				node = self.path.find_or_declare(masterfile)
				mastertask = self.create_task("MkMaster", [], node)
				mastertask.set_outputs(node)
				self.mastertasks.append(mastertask)
			cppnumleft = cppnumleft - 1
			mastertask.set_inputs(srcnode)

objcpydbg = '${OBJCOPY} ${OBJCOPYFLAGS} --only-keep-debug ${SRC[0].abspath()} ${TGT[0].abspath()}'
objcpydbgcls = Task.task_factory('dbg', objcpydbg, 'YELLOW', ext_in='.all', ext_out='.dbg', shell=False)
objcpystrip = '${OBJCOPY} ${OBJCOPYFLAGS} --localize-hidden --strip-debug --strip-unneeded --keep-symbol .gnu_debuglink --add-gnu-debuglink ${SRC[0].change_ext(".dbg").path_from(tsk.inputs[0].parent)} ${SRC[0].abspath()} ${TGT[0].abspath()}'
objcpystripcls = Task.task_factory('strip', objcpystrip, 'BLUE', ext_in='.all', shell=False)

@feature('cprogram', 'cxxprogram', 'cshlib', 'cxxshlib')
@after_method('apply_link')
@after_method('apply_implib')
@after_method('apply_implib_program')
def extract_debug_info(self):
	if self.env.CXX_NAME in ['gcc', 'sun'] and self.env.OBJCOPY:
		self.link_task_real = self.link_task
		innode = self.link_task_real.outputs[0]
		outnode = innode.change_ext('.all')
		debugnode = innode.change_ext('.dbg')
		self.link_task_real.outputs[0] = outnode

		self.link_debug_task = self.create_task('dbg', outnode)
		self.link_debug_task.set_outputs(debugnode)
		self.link_debug_task.set_run_after(self.link_task_real)

		try:
			inst_to = self.install_path
		except AttributeError:
			inst_to = self.link_task.__class__.inst_to
		self.bld.install_files(inst_to, self.link_debug_task.outputs[:], env=self.env)



		self.link_task = self.create_task('strip', outnode)
		self.link_task.set_outputs(innode)
		self.link_task.set_run_after(self.link_debug_task)

@feature('cprogram', 'cxxprogram')
@after_method('apply_link')
@before_method('apply_implib')
def apply_implib_program(self):
	ccroot.apply_implib(self)

from waflib.Build import BuildContext, CleanContext, InstallContext, UninstallContext, ListContext
from waflib import ConfigSet
try:
	env = ConfigSet.ConfigSet('.build/be_toolchains.py')
	for toolchain in env.BUILD_VARIANTS:
		for y in (BuildContext, CleanContext, InstallContext, UninstallContext, ListContext):
			name = y.__name__.replace('Context','').lower()
			class tmp(y):
				cmd = name + '_' + toolchain
				variant = toolchain
except:
	pass

class foo(BuildContext):
	cmd = 'build'
	fun = 'build'
	returned_tasks = []
	def compile(self):
		pass

