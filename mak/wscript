"""
    This is the main entry point for cofiguration abd build.
    This module is responsible for loading the tools, discovering the host
    and the targets and launching their respective configuration and builds,
    as well as the reconfigure target
"""

import os
import sys
from waflib import Configure, Build, ConfigSet, Context, Utils, Options, Logs, Errors, TaskGen
try:
    import cPickle as pickle
except ImportError:
    import pickle



def options(opt):
    "Creates main option groups and load options for the host and all targets"
    opt.add_option_group('SDK paths and options')
    opt.add_option_group('3rd party libraries')
    opt.bugenginenode = opt.path.parent

    opt.load('visualstudio', tooldir=[os.path.join(opt.path.abspath(), 'tools')])
    opt.load('xcode', tooldir=[os.path.join(opt.path.abspath(), 'tools')])
    opt.load('netbeans', tooldir=[os.path.join(opt.path.abspath(), 'tools')])
    opt.load('eclipse', tooldir=[os.path.join(opt.path.abspath(), 'tools')])
    opt.load('qtcreator', tooldir=[os.path.join(opt.path.abspath(), 'tools')])

    opt.recurse('build.py')
    opt.recurse('hosts.py')
    opt.recurse('compilers.py')
    opt.recurse('targets.py')
    opt.recurse('../src/3rdparty/mak/mak.py')
    third_party_node = opt.path.parent.make_node('src').make_node('3rdparty')
    for category in third_party_node.listdir():
        if category != 'mak':
            category_node = third_party_node.make_node(category)
            for third_party in category_node.listdir():
                opt.recurse('../src/3rdparty/%s/%s/%s.py'%(category, third_party, third_party))
    option_file = opt.path.parent.find_node('options')
    if option_file:
        with open(option_file.abspath(), 'r') as file:
            opt.parse_args(file.readlines())


def configure(conf):
    "Recursively calls configure on host and all targets to create all available toolchains"
    conf.bugenginenode = conf.path.parent
    conf.recurse('checks.py')
    conf.recurse('hosts.py')
    extra = conf.bugenginenode.make_node('extra')
    for extra_platform in extra.listdir():
        directory = extra.make_node(extra_platform).abspath()
        if os.path.isdir(directory) and os.path.isfile(os.path.join(directory, 'wscript')):
            conf.recurse(extra.make_node(extra_platform).abspath(), name='host_configure')
    conf.load('flex', tooldir=[os.path.join(conf.path.abspath(), 'tools')])
    conf.load('bison', tooldir=[os.path.join(conf.path.abspath(), 'tools')])
    conf.recurse('compilers.py')
    conf.recurse('targets.py')
    conf.env.ALL_TOOLCHAINS.sort(key=lambda x: x.split('-'))


def setup(conf):
    "setup step before the build: recursively cals setup on every third party library"
    conf.recurse('../src/3rdparty/mak/mak.py', name='setup', once=False)
    third_party_node = conf.path.parent.make_node('src').make_node('3rdparty')
    for category in third_party_node.listdir():
        if category != 'mak':
            conf.start_msg('      `- [%s]' % category)
            category_node = third_party_node.make_node(category)
            for third_party in category_node.listdir():
                conf.recurse('../src/3rdparty/%s/%s/%s.py'%(category, third_party, third_party),
                             name='setup',
                             once=False)
            conf.end_msg('')


def build(bld):
    "Loads main build file as well as the target-specific build file that can declare extra modules"
    bld.bugenginenode = bld.path.parent
    bld.common_env = bld.env
    if not bld.env.PROJECTS:
        if bld.bugengine_variant == '':
            raise Errors.WafError('Call %s %s %s:toolchain:variant, '
                                  'with toolchain in\n\t%s\nvariant in\n\t%s' %
                                  (sys.executable, sys.argv[0],
                                   bld.cmd,
                                   '\n\t'.join(bld.env.ALL_TOOLCHAINS),
                                   '\n\t'.join(bld.env.ALL_VARIANTS)))
        bld.env = bld.all_envs[bld.bugengine_variant]
    bld.platforms = []
    bld.recurse('build.py')
    bld.recurse('hosts.py')
    bld.recurse('targets.py')
    bld.recurse('install.py')

    if bld.env.PROJECTS:
        def rc_hook(self, node):
            "creates RC hook to silence waf error"
            #pylint: disable=unused-argument
            pass
        if '.rc' not in TaskGen.task_gen.mappings:
            TaskGen.task_gen.mappings['.rc'] = rc_hook


def plugins(bld):
    """
        Recursively calls plugins for host/target so each OS can declare their own platform-specific
        plugins
    """
    bld.recurse('hosts.py', name='plugins')
    bld.recurse('targets.py', name='plugins')



class ConfigurationContext(Configure.ConfigurationContext):
    """
        ConfigurationContext subclass, which allows to store the current environment used
        for configure so it can be restored during a reconfigure.
    """
    cmd = 'configure'
    def __init__(self, **kw):
        "main init"
        super(ConfigurationContext, self).__init__(**kw)

    def execute(self):
        """
            Executes the configuration, then stores the current status that can be checked
            during the reconfiguration step
        """
        super(ConfigurationContext, self).execute()
        self.store_options()

    def store_options(self):
        """
            Store last good configuration. This allows the build to automatically
            reconfigure when an environemnt variable changes, or a file changes on disc.
            The file will check common env variable as well as every wscript/python file
            loaded so far.
            Since this is called during the configuration step, the wscript/python files
            loaded during the build step only will not cause a reconfigure, which is the
            desired behaviour.
        """
        Options.options.path = os.environ['PATH']
        Options.options.include = os.environ.get('INCLUDE', '')
        Options.options.libpath = os.environ.get('LIBPATH', '')
        Options.options.lib = os.environ.get('LIB', '')
        Options.options.pwd = os.environ.get('PWD', '')
        node = self.bldnode.make_node('options.pickle')
        pickle.dump(Options.options, open(node.abspath(), 'wb'), protocol=2)


class ReconfigurationContext(Configure.ConfigurationContext):
    "reconfigures the project with the same options as the last call to configure"
    cmd = 'reconfigure'
    def __init__(self, **kw):
        "main init"
        super(ReconfigurationContext, self).__init__(**kw)

    def execute(self):
        """
            restores the environment as it was during the last run, then reconfigures
            the project.
        """
        opt = Options.options
        self.restore_options()
        super(ReconfigurationContext, self).execute()
        Options.options = opt

    def restore_options(self):
        """
            Restores the environment as it was during the configure step. This allows
            reconfigure to discover the same compilers, even if the reconfigure step
            is not started in the same environment as configure (e.g. called from an IDE)
        """
        self.init_dirs()
        try:
            node = self.bldnode.make_node('options.pickle')
            Options.options = pickle.load(open(node.abspath(), 'rb'))
            #pylint: disable=no-member
            os.environ['PATH'] = self.environ['PATH'] = Options.options.path
            os.environ['LIBPATH'] = self.environ['LIBPATH'] = Options.options.libpath
            os.environ['LIB'] = self.environ['LIB'] = Options.options.lib
            os.environ['INCLUDE'] = self.environ['INCLUDE'] = Options.options.include
            os.environ['PWD'] = self.environ['PWD'] = Options.options.pwd
        except IOError:
            raise Errors.WafError('Option file not found; configure the project first')


def autoreconfigure(execute_method):
    """
        Decorator used to set the commands that can be reconfigured automatically
    """
    def execute(self):
        """
            First check if reconfiguration is needed, then triggers the
            normal execute.
        """
        env = ConfigSet.ConfigSet()
        do_config = False
        env.load(os.path.join(Context.top_dir, Options.lockfile))
        if env.run_dir != Context.run_dir:
            do_config = True
        else:
            hash_value = 0
            for filename in env['files']:
                try:
                    hash_value = Utils.h_list((hash_value, Utils.readf(filename, 'rb')))
                except IOError:
                    do_config = True
            do_config = do_config or (hash_value != env.hash)

        if do_config:
            Logs.warn('wscript files have changed; reconfiguring the project')
            Options.commands.insert(0, self.cmd)
            Options.commands.insert(0, 'reconfigure')
            return

        return execute_method(self)
    return execute
Build.BuildContext.execute = autoreconfigure(Build.BuildContext.execute)


class ListToolchainsContext(Build.BuildContext):
    """
        Command that will print all available toolchains to stdout
    """
    cmd = 'list_toolchains'

    def execute(self):
        self.restore()
        if not self.all_envs:
            self.load_envs()
        for toolchain in self.env.ALL_TOOLCHAINS:
            print(toolchain)

class ListVariantsContext(Build.BuildContext):
    """
        Command that will print all available variants to stdout
    """
    cmd = 'list_variants'

    def execute(self):
        self.restore()
        if not self.all_envs:
            self.load_envs()
        for variant in self.env.ALL_VARIANTS:
            print(variant)
