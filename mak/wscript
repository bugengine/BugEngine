from waflib.Configure import conf
from waflib.TaskGen import feature, extension, before_method, after_method
from waflib import Errors
import os, sys


def module(bld, name, depends, valid_platforms, features, use_master, warnings):
	archs = bld.env.VALID_ARCHITECTURES
	platforms = bld.env.VALID_PLATFORMS
	platform_specific = archs + platforms + ['%s.%s'%(p,a) for p in platforms for a in archs]

	extensions = ['cxx', 'cpp', 'cc', 'c', 'rc', 'll', 'yy', 'so', 'dll', 'plist', 'png', 'pkg', 'lua']
	source_node = bld.bugenginenode.make_node('src/%s' % name.replace('.', '/'))
	sources = source_node.ant_glob(['%s/**/*.%s'%(s,ext) for s in ['src', 'bin', 'data'] for ext in extensions])
	sources += source_node.ant_glob(['%s/**/*.script.hh'%s for s in ['api', 'include']])
	api = [i for i in [source_node.make_node('api')] + [source_node.make_node('api.%s'%platform) for platform in platform_specific] if os.path.isdir(i.abspath())]
	include = [i for i in [source_node.make_node('include')] + [source_node.make_node('include.%s'%platform) for platform in platform_specific] if os.path.isdir(i.abspath())]
	lib_paths = [i.path_from(bld.bldnode) for i in [source_node.make_node('lib')] + [source_node.make_node('lib.%s'%platform) for platform in platform_specific] if os.path.isdir(i.abspath())]

	extras = []
	for platform in bld.bugenginenode.make_node('extra').listdir():
		path = os.path.join('extra', platform, '/'.join(name.split('.')))
		if os.path.isdir(path):
			extra_source_node = bld.bugenginenode.make_node(path)
			extras.append(extra_source_node)
			sources += extra_source_node.ant_glob('src/**/*.%s'%ext for ext in extensions + ['script.hh'])
			if platform in platforms:
				api += [extra_source_node.make_node('api')]
				include += [extra_source_node.make_node('include')]



	if api and os.path.isfile(os.path.join(api[0].path_from(bld.srcnode), name.split('.')[-1], 'stdafx.h')):
		pchstop = '%s/%s'%(name.split('.')[-1], 'stdafx.h')
	elif include and os.path.isfile(os.path.join(include[0].path_from(bld.srcnode), 'stdafx.h')):
		pchstop = 'stdafx.h'
	else:
		pchstop = None

	if use_master:
		features = features + ['master']
	if warnings:
		extra_features = ['warnall', bld.env.VARIANT]
	else:
		extra_features = ['warnnone', bld.env.VARIANT]

	build = len(valid_platforms) == 0
	for p in valid_platforms:
		if p in platforms:
			build = True

	if build:
		if os.path.isdir(os.path.join(source_node.abspath(), 'kernels')):
			kernelspath = source_node.make_node('kernels')
			for kernel in kernelspath.listdir():
				kernelpath = kernelspath.make_node(kernel)
				kernelsources = kernelpath.ant_glob(['**'])
				for toolchain in bld.env.KERNEL_TOOLCHAINS:
					env = bld.all_envs[toolchain]
					bld(
						target = name + '.' + kernel,
						features = ['cxx', 'cxxshlib', 'kernel'] + extra_features,
						includes = api+include+[bld.srcnode],
						source = kernelsources,
						env = env.derive(),
						use = depends + [name],
						install_path = os.path.join('build', bld.env.TOOLCHAIN, bld.env.VARIANT, bld.env.DEPLOY_KERNELDIR))
	else:
		sources = []
		if 'cxxshlib' in features:
			features.remove('cxxshlib')
		if 'cxxprogram' in features:
			features.remove('cxxprogram')
		if 'cxxstlib' in features:
			features.remove('cxxstlib')

	return bld(
		target = name,
		use = depends,
		features = features,
		extra_use = extra_features,
		defines = ['building_%s' % name.split('.')[-1], 'BE_PROJECTID=%s'%name.replace('.', '_'), 'BE_PROJECTNAME=%s'%name],
		export_defines = [],
		includes = api+include+[bld.srcnode],
		libs = [],
		lib_paths = lib_paths,
		export_includes = api,
		frameworks = [],
		source = sources,
		pchstop = pchstop,
		source_nodes = [source_node] + extras)

@conf
def external(bld, name):
	bld.recurse(os.path.join(bld.bugenginenode.abspath(), 'src', name.replace('.', '/')))
	return name

@conf
def thirdparty(bld, name, libs=[], lib_paths=[], frameworks=[], includes=[], defines=[], use_master=True, warnings=True):
	archs = bld.env.VALID_ARCHITECTURES
	platforms = bld.env.VALID_PLATFORMS
	platform_specific = archs + platforms + ['%s.%s'%(p,a) for p in platforms for a in archs]
	source_node = bld.bugenginenode.make_node('src/%s' % name.replace('.', '/'))

	lib_paths += [i.path_from(bld.bldnode) for i in [source_node.make_node('lib')] + [source_node.make_node('lib.%s'%platform) for platform in platform_specific] if os.path.isdir(i.abspath())]
	includes += [i for i in [source_node.make_node('api')] + [source_node.make_node('api.%s'%platform) for platform in platform_specific] if os.path.isdir(i.abspath())]

	bld.env['DEFINES_%s' % name] = defines
	bld.env['INCLUDES_%s' % name] = includes
	bld.env['FRAMEWORK_%s' % name] = frameworks
	bld.env['LIBPATH_%s' % name] = lib_paths
	bld.env['LIB_%s' % name] = libs

@conf
def library(bld, name, depends=[], features=[], platforms=[], use_master=True, warnings=True):
	for f in features:
		if f not in bld.features:
			return None
	for p in platforms:
		if p not in bld.env.VALID_PLATFORMS:
			return None
	return module(bld, name, depends, platforms, ['cxx', 'cxxobjects'], use_master, warnings)

@conf
def static_library(bld, name, depends=[], features=[], platforms=[], use_master=True, warnings=True):
	for f in features:
		if f not in bld.features:
			return None
	for p in platforms:
		if p not in bld.env.VALID_PLATFORMS:
			return None
	return module(bld, name, depends, platforms, ['cxx', 'cxxstlib'], use_master, warnings)

@conf
def shared_library(bld, name, depends=[], features=[], platforms=[], use_master=True, warnings=True):
	for f in features:
		if f not in bld.features:
			return None
	for p in platforms:
		if p not in bld.env.VALID_PLATFORMS:
			return None
	return module(bld, name, depends, platforms, ['cxx', 'cxxshlib'], use_master, warnings)

@conf
def engine(bld, name, depends=[], features=[], platforms=[], use_master=True, warnings=True):
	for f in features:
		if f not in bld.features:
			return None
	for p in platforms:
		if p not in bld.env.VALID_PLATFORMS:
			return None
	m = module(bld, name, depends, platforms, ['cxx', 'cxxprogram', 'launcher'], use_master, warnings)
	m.install_path = os.path.join('build', bld.env.TOOLCHAIN, bld.env.VARIANT, bld.env.DEPLOY_BINDIR)
	return m

@conf
def game(bld, name, depends=[], features=[], platforms=[], use_master=True, warnings=True):
	for f in features:
		if f not in bld.features:
			return None
	for p in platforms:
		if p not in bld.env.VALID_PLATFORMS:
			return None
	m = module(bld, name, depends,platforms,  ['cxx', 'cxxshlib', 'plugin', 'game'], use_master, warnings)
	m.install_path = os.path.join('build', bld.env.TOOLCHAIN, bld.env.VARIANT, bld.env.DEPLOY_PLUGINDIR)
	return m

@conf
def plugin(bld, name, depends=[], features=[], platforms=[], use_master=True, warnings=True):
	for f in features:
		if f not in bld.features:
			return None
	for p in platforms:
		if p not in bld.env.VALID_PLATFORMS:
			return None
	m = module(bld, name, depends, platforms, ['cxx', 'cxxshlib', 'plugin'], use_master, warnings)
	m.install_path = os.path.join('build', bld.env.TOOLCHAIN, bld.env.VARIANT, bld.env.DEPLOY_PLUGINDIR)
	return m

def options(opt):
	gr = opt.get_option_group('build and install options')
	gr.add_option(	'--nomaster',
					action = 'store_true',
					default = False,
					dest = 'nomaster',
					help = 'build without master files')

	opt.bugenginenode = opt.path.parent
	opt.recurse('host')
	opt.recurse('compiler')
	opt.recurse('source')
	opt.recurse('target')
	for third_party in opt.path.parent.make_node('src').make_node('3rdparty').listdir():
		opt.recurse('../src/3rdparty/%s'%third_party)
	opt.load('visualstudio', tooldir=['mak/tools'])
	opt.load('xcode', tooldir=['mak/tools'])
	opt.load('netbeans', tooldir=['mak/tools'])

def configure(conf):
	conf.bugenginenode = conf.path.parent
	conf.recurse('checks')
	conf.recurse('host')
	conf.recurse('compiler')
	conf.recurse('source')
	conf.recurse('target')
	conf.env.ALL_TOOLCHAINS.sort(key = lambda x: x.split('-'))

def setup(conf):
	for third_party in conf.bugenginenode.make_node('src').make_node('3rdparty').listdir():
		conf.recurse('../src/3rdparty/%s'%third_party, name='setup', once=False)

def build(bld):
	bld.bugenginenode = bld.path.parent
	if bld.variant == '' and not bld.env.PROJECTS:
		raise Errors.WafError('Call %s %s %s:toolchain:variant, with toolchain in\n\t%s\nvariant in\n\t%s' %
								(sys.executable, sys.argv[0], bld.cmd, '\n\t'.join(bld.env.ALL_TOOLCHAINS), '\n\t'.join(bld.env.ALL_VARIANTS)))
	bld.platforms = []
	bld.features = getattr(bld, 'features', [])
	bld.bugenginenode = bld.path.parent
	bld.recurse('host')
	bld.recurse('source')
	bld.recurse('target')

def plugins(bld):
	bld.recurse('host')
	bld.recurse('target')



@feature('*')
def check_use_taskgens(self):
	"""
	Checks all names in 'use' are valid task generators, or move them to uselib
	"""
	use = getattr(self, 'use', [])
	for name in use:
		if name not in self.env.ALL_VARIANTS:
			try:
				y = self.bld.get_tgen_by_name(name)
			except:
				try:
					self.uselib.append(name)
				except AttributeError:
					self.uselib = [name]

@feature('cxx')
def set_building_name_inherits(self):
	seen = set([])
	use = getattr(self, 'use', [])[:]
	while (use):
		x = use.pop()
		try:
			y = self.bld.get_tgen_by_name(x)
		except:
			pass
		else:
			if 'cxxobjects' in y.features:
				use += getattr(y, 'use', [])
				self.env.DEFINES.append('building_%s' % y.target.split('.')[-1])


@feature('plugin')
def plugin_feature(task):
	pass

@feature('game')
def game_feature(task):
	pass

@feature('launcher')
def launcher_feature(task):
	pass

@feature('cxxobjects')
def objects_feature(task):
	pass

@feature('kernel', 'plugin')
@after_method('process_use')
def remove_link_libs(task):
	if not task.env.LINK_WITH_PROGRAM:
		libs = task.env.LIB[:]
		for l in libs:
			try:
				task_gen = task.bld.get_tgen_by_name(l)
				if 'cxxprogram' in task_gen.features:
					task.env.LIB.remove(l)
			except:
				pass

@feature('cxx')
def set_extra_flags(self):
	for f in getattr(self, 'extra_use', []):
		self.env.append_unique('CFLAGS', self.env['CFLAGS_%s'%f])
		self.env.append_unique('CXXFLAGS', self.env['CXXFLAGS_%s'%f])
		self.env.append_unique('LINKFLAGS', self.env['LINKFLAGS_%s'%f])

from waflib import Configure, Build, ConfigSet, Context, Utils, Options, Errors, Logs
try:
	import cPickle as pickle
except:
	import pickle

class ConfigurationContext(Configure.ConfigurationContext):
	cmd ='configure'
	def __init__(self, **kw):
		super(ConfigurationContext, self).__init__(**kw)

	def execute(self):
		super(ConfigurationContext, self).execute()
		self.store_options()

	def store_options(self):
		Options.options.path = os.environ['PATH']
		Options.options.include = os.environ.get('INCLUDE', '')
		Options.options.libpath = os.environ.get('LIBPATH', '')
		Options.options.lib = os.environ.get('LIB', '')
		node = self.bldnode.make_node('options.pickle')
		pickle.dump(Options.options, open(node.abspath(), 'wb'), protocol = 2)

from waflib import Configure
class ReconfigurationContext(Configure.ConfigurationContext):
	cmd ='reconfigure'
	def __init__(self, **kw):
		super(ReconfigurationContext, self).__init__(**kw)

	def execute(self):
		self.restore_options()
		super(ReconfigurationContext, self).execute()

	def restore_options(self):
		self.init_dirs()
		try:
			node = self.bldnode.make_node('options.pickle')
			Options.options = pickle.load(open(node.abspath(), 'rb'))
			os.environ['PATH'] = self.environ['PATH'] = Options.options.path
			os.environ['LIBPATH'] = self.environ['LIBPATH'] = Options.options.libpath
			os.environ['LIB'] = self.environ['LIB'] = Options.options.lib
			os.environ['INCLUDE'] = self.environ['INCLUDE'] = Options.options.include

		except IOError:
			raise Errors.WafError('Option file not found; configure the project first')


def autoreconfigure(execute_method):
	"""
	Decorator used to set the commands that can be reconfigured automatically
	"""
	def execute(self):
		env = ConfigSet.ConfigSet()
		do_config = False
		env.load(os.path.join(Context.top_dir, Options.lockfile))
		if env.run_dir != Context.run_dir:
			do_config = True
		else:
			h = 0
			for f in env['files']:
				h = hash((h, Utils.readf(f, 'rb')))
			do_config = h != env.hash

		if do_config:
			Logs.warn('wscrip files have changed; reconfiguring the project')
			Options.commands.insert(0, self.cmd)
			Options.commands.insert(0, 'reconfigure')
			return

		return execute_method(self)
	return execute
Build.BuildContext.execute = autoreconfigure(Build.BuildContext.execute)

