from waflib import Errors, TaskGen
import os, sys


def options(opt):
    gr = opt.add_option_group('SDK paths and options')
    opt.bugenginenode = opt.path.parent

    opt.load('visualstudio', tooldir=[os.path.join(opt.path.abspath(), 'tools')])
    opt.load('xcode', tooldir=[os.path.join(opt.path.abspath(), 'tools')])
    opt.load('netbeans', tooldir=[os.path.join(opt.path.abspath(), 'tools')])
    opt.load('eclipse', tooldir=[os.path.join(opt.path.abspath(), 'tools')])
    opt.load('qtcreator', tooldir=[os.path.join(opt.path.abspath(), 'tools')])

    opt.recurse('build.py')
    opt.recurse('hosts.py')
    opt.recurse('compilers.py')
    opt.recurse('targets.py')
    for third_party in opt.path.parent.make_node('src').make_node('3rdparty').listdir():
        opt.recurse('../src/3rdparty/%s/%s.py'%(third_party, third_party))
    option_file = opt.path.parent.find_node('options')
    if option_file:
        with open(option_file.abspath(), 'r') as f:
            opt.parse_args(f.readlines())

def configure(conf):
    conf.bugenginenode = conf.path.parent
    conf.recurse('checks.py')
    conf.recurse('hosts.py')
    extra = conf.bugenginenode.make_node('extra')
    for e in extra.listdir():
        directory = extra.make_node(e).abspath()
        if os.path.isdir(directory) and os.path.isfile(os.path.join(directory, 'wscript')):
            conf.recurse(extra.make_node(e).abspath(), name='host_configure')
    conf.recurse('compilers.py')
    conf.recurse('targets.py')
    conf.load('flex', tooldir=[os.path.join(conf.path.abspath(), 'tools')])
    conf.load('bison', tooldir=[os.path.join(conf.path.abspath(), 'tools')])
    conf.load('kernel_preprocess', tooldir=[os.path.join(conf.path.abspath(), 'tools')])

    conf.env.ALL_TOOLCHAINS.sort(key = lambda x: x.split('-'))

def setup(conf):
    conf.detected = []
    conf.start_msg("Checking libraries")
    for third_party in conf.bugenginenode.make_node('src').make_node('3rdparty').listdir():
        conf.recurse('../src/3rdparty/%s/%s.py'%(third_party, third_party), name='setup', once=False)
    conf.end_msg(', '.join(conf.detected) or False)

def build(bld):
    bld.bugenginenode = bld.path.parent
    bld.common_env = bld.env
    if bld.bugengine_variant == '' and not bld.env.PROJECTS:
        raise Errors.WafError('Call %s %s %s:toolchain:variant, with toolchain in\n\t%s\nvariant in\n\t%s' %
                                (sys.executable, sys.argv[0], bld.cmd, '\n\t'.join(bld.env.ALL_TOOLCHAINS), '\n\t'.join(bld.env.ALL_VARIANTS)))
    bld.env = bld.all_envs[bld.bugengine_variant]
    bld.platforms = []
    bld.recurse('build.py')
    bld.recurse('hosts.py')
    bld.recurse('targets.py')

    if bld.env.PROJECTS:
        def rc_hook(self, node):
            pass
        if not '.rc' in TaskGen.task_gen.mappings:
            TaskGen.task_gen.mappings['.rc'] = rc_hook

def plugins(bld):
    bld.recurse('hosts.py', name='plugins')
    bld.recurse('targets.py', name='plugins')


from waflib import Configure, Build, ConfigSet, Context, Utils, Options, Logs
try:
    import cPickle as pickle
except:
    import pickle

class ConfigurationContext(Configure.ConfigurationContext):
    cmd ='configure'
    def __init__(self, **kw):
        super(ConfigurationContext, self).__init__(**kw)

    def execute(self):
        super(ConfigurationContext, self).execute()
        self.store_options()

    def store_options(self):
        Options.options.path = os.environ['PATH']
        Options.options.include = os.environ.get('INCLUDE', '')
        Options.options.libpath = os.environ.get('LIBPATH', '')
        Options.options.lib = os.environ.get('LIB', '')
        Options.options.pwd = os.environ.get('PWD', '')
        node = self.bldnode.make_node('options.pickle')
        pickle.dump(Options.options, open(node.abspath(), 'wb'), protocol = 2)

from waflib import Configure
class ReconfigurationContext(Configure.ConfigurationContext):
    "reconfigures the project with the same options as the last call to configure"
    cmd ='reconfigure'
    def __init__(self, **kw):
        super(ReconfigurationContext, self).__init__(**kw)

    def execute(self):
        opt = Options.options
        self.restore_options()
        super(ReconfigurationContext, self).execute()
        Options.options = opt

    def restore_options(self):
        self.init_dirs()
        try:
            node = self.bldnode.make_node('options.pickle')
            Options.options = pickle.load(open(node.abspath(), 'rb'))
            os.environ['PATH'] = self.environ['PATH'] = Options.options.path
            os.environ['LIBPATH'] = self.environ['LIBPATH'] = Options.options.libpath
            os.environ['LIB'] = self.environ['LIB'] = Options.options.lib
            os.environ['INCLUDE'] = self.environ['INCLUDE'] = Options.options.include
            os.environ['PWD'] = self.environ['PWD'] = Options.options.pwd
        except IOError:
            raise Errors.WafError('Option file not found; configure the project first')


def autoreconfigure(execute_method):
    """
    Decorator used to set the commands that can be reconfigured automatically
    """
    def execute(self):
        env = ConfigSet.ConfigSet()
        do_config = False
        env.load(os.path.join(Context.top_dir, Options.lockfile))
        if env.run_dir != Context.run_dir:
            do_config = True
        else:
            h = 0
            for f in env['files']:
                try:
                    h = Utils.h_list((h, Utils.readf(f, 'rb')))
                except IOError:
                    do_config = True
            do_config = do_config or (h != env.hash)

        if do_config:
            Logs.warn('wscript files have changed; reconfiguring the project')
            Options.commands.insert(0, self.cmd)
            Options.commands.insert(0, 'reconfigure')
            return

        return execute_method(self)
    return execute
Build.BuildContext.execute = autoreconfigure(Build.BuildContext.execute)
