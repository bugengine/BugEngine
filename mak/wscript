#set general options for building

import os
import re
import Options
from Logs import warn
from TaskGen import taskgen,feature,before,after
import Task
import Node
import misc
import module
import mak

from mak.tools.IDE import visualstudio,netbeans,xcode

def expandPlatforms(platforms):
	result = []
	for p in platforms:
		try: result += mak.platformaliases[p]
		except KeyError: result += [p]
	return result

def set_options(opt):
	opt.sub_options(os.path.join('host', os.name))
	for l in 'platforms','archs':
		for target in os.listdir(os.path.join('mak', 'target', l)):
			if target not in ['.svn', '.cvs']:
				opt.sub_options(os.path.join('target', l, target))
	opt.add_option( '--projects',
					action='store',
					default='',
					help='build projects for the selected IDEs')
	opt.add_option( '--toolchains',
					action='store',
					default='',
					help='build for the selected toolchains; default is the most adapted toolchain, version release, static')
	opt.add_option( '--master',
					action='store_true',
					default=True,
					help='build with master files')

def configure(conf):
	conf.env['ARCHITECTURES'] = mak.allarchs
	conf.env['PLATFORMS']	  = mak.allplatforms
	conf.env['OPTIMS']		  = mak.alloptims

	conf.sub_config(os.path.join('host', os.name))
	for p in ['win32', 'linux', 'sunos']:
		conf.sub_config(os.path.join('target', 'platforms', p))
	if os.path.isdir('extra'):
		for f in os.listdir('extra'):
			if f in ['.svn', '.cvs']:
				continue
			if os.path.isdir(os.path.join('extra', f)) and os.path.isfile(os.path.join('extra', f, 'wscript')):
				conf.sub_config(os.path.join('..', 'extra', f))

	if len(conf.env['BUILD_VARIANTS']) == 0:
		raise SystemExit("no match found : make sure you selected a valid toolchain")
	conf.env['DEFAULT_BUILD_TOOL'] = conf.env['BUILD_VARIANTS'][-1]

	selectedvariants = []
	for optim in mak.alloptims:
		for envname in conf.env['BUILD_VARIANTS']:
			name = optim+'-'+envname
			env = conf.set_env_name(name, conf.all_envs[envname].copy())
			env.set_variant(name)
			env['OPTIMISATION'] = optim
			env['PREFIX'] = name
			selectedvariants.append(name)

	conf.env['BUILD_VARIANTS'] = selectedvariants

	if Options.options.toolchains:
		conf.env['SELECTED_TOOLCHAINS'] = Options.options.toolchains
		selectedtoolchains = [re.compile(selected) for selected in conf.env['SELECTED_TOOLCHAINS'].split(',')]
		allvariants = conf.env['BUILD_VARIANTS']
		selectedvariants = []
		for v in allvariants:
			for e in selectedtoolchains:
				if e.match(v):
					print 'selected variant',v,'for build'
					selectedvariants.append(v)
		if not selectedvariants:
			conf.fatal('No toolchain matches the pattern %s, available : %s' % (Options.options.toolchains,str(allvariants)))
	else:
		conf.env['SELECTED_TOOLCHAINS'] = 'debug-'+conf.env['DEFAULT_BUILD_TOOL']
		print 'selected variant',conf.env['SELECTED_TOOLCHAINS'],'for build'
	unusedvariants = []
	for envname,env in conf.all_envs.iteritems():
		if not envname in conf.env['BUILD_VARIANTS'] and envname != 'default':
			unusedvariants.append(envname)
	for envname in unusedvariants:
		del conf.all_envs[envname]



def build(bld):
	for l in 'platforms','archs':
		for target in os.listdir(os.path.join('mak', 'target', l)):
			if target not in ['.svn', '.cvs']:
				bld.add_subdirs(os.path.join('target', l, target))
	import Options
	if not Options.options.toolchains:
		Options.options.toolchains = bld.env['SELECTED_TOOLCHAINS']
	selectedtoolchains = [re.compile(selected) for selected in Options.options.toolchains.split(',')]
	selectedvariants = []
	if Options.options.projects:
		bld.env['PROJECTS'] = Options.options.projects.split(',')
	else:
		allvariants = bld.env['BUILD_VARIANTS']
		for v in allvariants:
			for e in selectedtoolchains:
				if e.match(v):
					selectedvariants.append(v)
					print 'selected variant',v,'for build'
	bld.env['BUILD_VARIANTS'] = selectedvariants
	global builder
	mak.builder = bld

@taskgen
@feature('cc','cxx')
@before('apply_core')
def filter_sources(self):
	v = self.env
	self.source = self.to_list(self.source)
	rejectedsources = []
	self.allsources = {}
	for source in self.source:
		head,tail = os.path.split(source)
		while tail:
			head,tail = os.path.split(head)
			if tail[0:5] == 'arch=':
				archs=set(tail[5:].split(','))
				if not v['ARCHITECTURE'] in archs:
					try: self.allsources[tail].append(source)
					except KeyError: self.allsources[tail] = [source]
					rejectedsources.append(source)
					continue
			if tail[0:9] == 'platform=':
				platforms=(tail[9:].split(','))
				if not v['PLATFORM'] in expandPlatforms(platforms):
					try: self.allsources[tail].append(source)
					except KeyError: self.allsources[tail] = [source]
					rejectedsources.append(source)
					continue
	for src in rejectedsources:
		self.source.remove(src)

@taskgen
@feature('cprogram', 'cshlib', 'cstaticlib')
@after('apply_link')
@before('apply_lib_vars')
def add_extra_libs(self):
	env = self.env
	for lib in getattr(self,'extralibs',[]):
		env.append_value('LIB', lib)
	for libpath in getattr(self,'extralibdirs',[]):
		libpath = self.path.find_dir(libpath)
		if not libpath.srcpath(self.env) in env['LIBPATH']: env.append_value('LIBPATH', libpath.srcpath(self.env))

@taskgen
@feature('cobjects')
def add_cobjects_method(self):
	pass

def createmasterfile(task):
	f = open(task.outputs[0].bldpath(task.env), 'w')
	for src in task.inputs:
		f.write('#include "../%s"\n' % src.bldpath(task.env).replace('\\','/'))
	f.close()

MasterTask = Task.task_type_from_func("MkMaster", createmasterfile)

@feature('cprogram', 'cshlib')
@after('apply_link')
@before('apply_link_vars')
def add_extra_outputs(self):
	if self.env['CC_NAME'] == 'msvc':
		self.link_task.outputs.append(self.link_task.outputs[0].change_ext('.pdb'))
	if 'win32' == self.env['PLATFORM']:
		dll = self.link_task.outputs[0]
		implib = dll.parent.find_or_declare(self.env['implib_PATTERN'] % os.path.split(self.target)[1])
		self.env.append_value('LINKFLAGS', (self.env['IMPLIB_ST'] % implib.bldpath(self.env)).split())
		self.link_task.outputs.append(implib)
	
@feature('cc', 'cxx')
@after('apply_link', 'init_cc', 'init_cxx')
@before('apply_lib_vars')
def apply_lib_vars_cprogram(self):
	env = self.env
	uselib = self.to_list(self.uselib)
	seen = []
	names = self.to_list(self.uselib_local)[:] # consume a copy of the list of names
	while names:
		x = names.pop(0)
		# visit dependencies only once
		if x in seen:
			continue

		y = self.name_to_obj(x)
		if not y:
			raise Utils.WafError("object '%s' was not found in uselib_local (required by '%s')" % (x, self.name))

		# object has ancestors to process: add them to the end of the list
		if getattr(y, 'uselib_local', None):
			lst = y.to_list(y.uselib_local)
			for u in lst:
				if not u in seen:
					names.append(u)

		# safe to process the current object
		y.post()
		seen.append(x)

		libname = y.target[y.target.rfind(os.sep) + 1:]
		if 'cprogram' in y.features:
			if 'win32' in env['PLATFORM']:
				env.append_value('LIB', libname)

		# set the dependency over the link task
		if self.link_task is not None and y.link_task is not None:
			self.link_task.set_run_after(y.link_task)
			dep_nodes = getattr(self.link_task, 'dep_nodes', [])
			self.link_task.dep_nodes = dep_nodes + y.link_task.outputs

			# add the link path too
			tmp_path = y.link_task.outputs[0].parent.bldpath(self.env)
			if not tmp_path in env['LIBPATH']: env.prepend_value('LIBPATH', tmp_path)

		# add ancestors uselib too
		morelibs = y.to_list(y.uselib)
		for v in morelibs:
			if v in uselib: continue
			uselib = [v]+uselib


@taskgen
@feature('cc','cxx')
@before('apply_core')
@after('filter_sources')
def make_masterfiles(self):
	if Options.options.master and self.usemaster and self.source:
		self.originalsources = self.source
		self.originalsources.sort()
		self.mastertasks = []
		self.source = []
		mastertask = None
		cindex	 = 0
		cppindex = 0
		cnumleft = 0
		cppnumleft = 0
		for f in self.originalsources:
			if os.path.splitext(f)[1] not in ['.c', '.C', '.cc', '.cpp', '.cxx']:
				self.source.append(f)
				continue
			srcnode = self.path.find_resource(f)
			if os.path.splitext(f)[1] == '.c':
				if cnumleft == 0:
					cnumleft = 30
					masterfile = self.target+'-c-master%d.c' % cindex
					cindex = cindex + 1
					self.source.append(masterfile)
					mastertask = MasterTask(self.env,)
					node = self.path.find_or_declare(masterfile)
					mastertask.set_outputs(node)
					self.mastertasks.append(mastertask)
				cnumleft = cnumleft - 1
				mastertask.set_inputs(srcnode)
			else:
				if cppnumleft == 0:
					cppnumleft = 30
					masterfile = self.target+'-cpp-master%d.cpp' % cppindex
					cppindex = cppindex + 1
					self.source.append(masterfile)
					mastertask = MasterTask(self.env,)
					node = self.path.find_or_declare(masterfile)
					mastertask.set_outputs(node)
					self.mastertasks.append(mastertask)
				cppnumleft = cppnumleft - 1
				mastertask.set_inputs(srcnode)

