#set general options for building

import os
import re
from waflib.TaskGen import taskgen_method,feature,before_method,after_method,extension,before
from waflib import Options,Task,Node,Errors
import mak
from mak import module
from waflib.Logs import pprint
from waflib.Tools import ccroot


def options(opt):
	opt.recurse(os.path.join('host', os.name))
	opt.load('visualstudio netbeans xcode', tooldir='mak/tools/IDE')
	#opt.load('parallel_debug', tooldir='mak/waflib/extras')
	for l in 'platforms','archs':
		for target in os.listdir(os.path.join('mak', 'target', l)):
			if target not in ['.svn', '.cvs']:
				opt.recurse(os.path.join('target', l, target))
	if os.path.isdir('extra'):
		for f in os.listdir('extra'):
			if f in ['.svn', '.cvs']:
				continue
			if os.path.isdir(os.path.join('extra', f)) and os.path.isfile(os.path.join('extra', f, 'wscript')):
				opt.recurse(os.path.join('..', 'extra', f))
	opt.add_option( '--projects',
					action='store',
					default='',
					dest='projects',
					help='build projects for the selected IDEs')
	opt.add_option( '--toolchains',
					action='store',
					default='',
					dest='toolchains',
					help='build for the selected toolchains')
	opt.add_option( '--master',
					action='store_true',
					default=True,
					dest='master',
					help='build with master files')

def configure(conf):
	conf.env['ARCHITECTURES']	= mak.allarchs

	#conf.load('parallel_debug', tooldir='mak/waflib/extras')
	conf.load('visualstudio netbeans xcode', tooldir='mak/tools/IDE')
	conf.recurse(os.path.join('host', os.name))
	for platform in os.listdir(os.path.join('mak', 'target', 'platforms')):
			if platform not in ['.svn', '.cvs']:
				pprint('BLUE', '==================================')
				pprint('BLUE', '= configure for target '+platform)
				conf.recurse(os.path.join('target', 'platforms', platform))
	if os.path.isdir('extra'):
		for f in os.listdir('extra'):
			if f in ['.svn', '.cvs']:
				continue
			if os.path.isdir(os.path.join('extra', f)) and os.path.isfile(os.path.join('extra', f, 'wscript')):
				pprint('BLUE', '==================================')
				pprint('BLUE', '= configure for target '+f)
				conf.recurse(os.path.join('..', 'extra', f))

	if len(conf.env['BUILD_VARIANTS']) == 0:
		raise SystemExit("no match found : make sure you selected a valid toolchain")
	conf.env['DEFAULT_BUILD_TOOL'] = conf.env['BUILD_VARIANTS'][-1]

	selectedvariants = []
	for optim in mak.alloptims:
		for envname in conf.env['BUILD_VARIANTS']:
			name = optim+'-'+envname
			conf.setenv(name, conf.all_envs[envname])
			conf.env['OPTIMISATION'] = optim
			conf.env['PREFIX'] = name
			selectedvariants.append(name)

	conf.variant = ''
	conf.env['BUILD_VARIANTS'] = selectedvariants

	if Options.options.toolchains:
		conf.env['SELECTED_TOOLCHAINS'] = Options.options.toolchains
		selectedtoolchains = [re.compile(selected) for selected in conf.env['SELECTED_TOOLCHAINS'].split(',')]
		allvariants = conf.env['BUILD_VARIANTS']
		selectedvariants = []
		for v in allvariants:
			for e in selectedtoolchains:
				if e.match(v):
					pprint('GREEN', 'selected variant %s for build' % v)
					selectedvariants.append(v)
		if not selectedvariants:
			conf.fatal('No toolchain matches the pattern %s, available : %s' % (Options.options.toolchains,str(allvariants)))
	else:
		conf.env['SELECTED_TOOLCHAINS'] = 'debug-'+conf.env['DEFAULT_BUILD_TOOL']
		pprint('GREEN', 'selected variant %s for build' % str(conf.env['SELECTED_TOOLCHAINS']))
	conf.env.store('.build/be_toolchains.py')

def selectToolchains(ctx):
	if not Options.options.toolchains:
		Options.options.toolchains = ctx.env['SELECTED_TOOLCHAINS']
	selectedtoolchains = [re.compile(selected) for selected in Options.options.toolchains.split(',')]
	selectedvariants = []
	if Options.options.projects:
		ctx.env['PROJECTS'] = Options.options.projects.split(',')
	else:
		allvariants = ctx.env['BUILD_VARIANTS']
		for v in allvariants:
			for e in selectedtoolchains:
				if e.match(v):
					selectedvariants.append(v)
					pprint('GREEN', 'selected variant %s for build' % v)
	ctx.env['BUILD_VARIANTS'] = selectedvariants

def build(bld):
	for l in 'platforms','archs':
		for target in os.listdir(os.path.join('mak', 'target', l)):
			if target not in ['.svn', '.cvs']:
				bld.recurse(os.path.join('target', l, target))
	if os.path.isdir('extra'):
		for target in os.listdir(os.path.join('extra')):
			if target not in ['.svn', '.cvs']:
				bld.recurse(os.path.join('..', 'extra', target))
	selectToolchains(bld)
	global builder
	mak.builder = bld

def clean(ctx):
	selectToolchains(ctx)

def install(ctx):
	selectToolchains(ctx)

def uninstall(ctx):
	selectToolchains(ctx)

@extension('.m')
def m_hook(self, node):
	"""Alias .m files to be compiled the same as .c files, gcc will do the right thing."""
	return self.create_compiled_task('c', node)

@extension('.mm')
def mm_hook(self, node):
	"""Alias .mm files to be compiled the same as .cxx files, gcc will do the right thing."""
	return self.create_compiled_task('cxx', node)

@taskgen_method
@feature('c','cxx')
@before_method('process_source')
def filter_sources(self):
	v = self.env
	self.source = self.to_list(self.source)
	rejectedsources = []
	self.allsources = {}
	for source in self.source:
		head,tail = os.path.split(source)
		while tail:
			head,tail = os.path.split(head)
			if tail[0:5] == 'arch=':
				archs=set(tail[5:].split(','))
				if not v['ARCHITECTURE'] in archs:
					try: self.allsources[tail].append(source)
					except KeyError: self.allsources[tail] = [source]
					rejectedsources.append(source)
					continue
			if tail[0:9] == 'platform=':
				platforms=set(tail[9:].split(','))
				if not set(v['PLATFORM']) & platforms:
					try: self.allsources[tail].append(source)
					except KeyError: self.allsources[tail] = [source]
					rejectedsources.append(source)
					continue
	for src in rejectedsources:
		self.source.remove(src)

@feature('c', 'cxx')
@before_method('apply_incpaths')
@after_method('propagate_uselib_vars')
def private_headers(self):
	self.env.append_value('DEFINES', getattr(self, 'private_defines', []))
	self.env.append_value('INCLUDES', getattr(self, 'private_includes', []))

@feature('cobjects')
def dummy_cobjects(self):
	pass




def createmasterfile(task):
	f = open(task.outputs[0].abspath(), 'w')
	for src in task.inputs:
		f.write('#include "%s"\n' % src.abspath().replace('\\','/'))
	f.close()

MasterTask = Task.task_factory("MkMaster", createmasterfile)

@taskgen_method
@feature('master')
@before_method('process_source')
@after_method('filter_sources')
@before('c', 'cxx')
def make_masterfiles(self):
	if not Options.options.master:
		return
	self.originalsources = self.source[:]
	self.originalsources.sort()
	self.mastertasks = []
	self.source = []
	mastertask = None
	cindex	 = 0
	cppindex = 0
	cnumleft = 0
	cppnumleft = 0
	for f in self.originalsources:
		if os.path.splitext(f)[1] not in ['.c', '.C', '.cc', '.cpp', '.cxx', '.hh']:
			self.source.append(f)
			continue
		if os.path.splitext(f)[1] == '.hh':
			self.source.append(f)
			srcnode = self.path.find_resource(f).change_ext('.cc')
		else:
			srcnode = self.path.find_resource(f)
		if os.path.splitext(f)[1] == '.c':
			if cnumleft == 0:
				cnumleft = 30
				masterfile = self.target+'-c-master%d.c' % cindex
				cindex = cindex + 1
				self.source.append(masterfile)
				node = self.path.find_or_declare(masterfile)
				mastertask = self.create_task("MkMaster", [], node)
				self.mastertasks.append(mastertask)
			cnumleft = cnumleft - 1
			mastertask.set_inputs(srcnode)
		else:
			if cppnumleft == 0:
				cppnumleft = 30
				masterfile = self.target+'-cpp-master%d.cpp' % cppindex
				cppindex = cppindex + 1
				self.source.append(masterfile)
				node = self.path.find_or_declare(masterfile)
				mastertask = self.create_task("MkMaster", [], node)
				mastertask.set_outputs(node)
				self.mastertasks.append(mastertask)
			cppnumleft = cppnumleft - 1
			mastertask.set_inputs(srcnode)


