from waflib.Configure import conf
from waflib.TaskGen import feature, extension
from waflib import Node, Errors, Utils
import os, sys


def module(bld, name, depends, features):
	archs = bld.env.VALID_ARCHITECTURES
	platforms = bld.env.VALID_PLATFORMS
	platform_specific = archs + platforms + ['%s.%s'%(p,a) for p in platforms for a in archs]

	extensions = ['cxx', 'cpp', 'cc', 'c', 'rc', 'll', 'yy', '.so', '.dll', '.plist', '.png']
	source_node = bld.bugenginenode.make_node('src/%s' % name.replace('.', '/'))
	sources = source_node.ant_glob(['%s/**/*.%s'%(s,ext) for s in ['src', 'bin', 'data'] for ext in extensions])
	sources += source_node.ant_glob(['%s/**/*.script.hh'%s for s in ['api', 'include']])
	all_sources = source_node.ant_glob(['**'])
	api = source_node.make_node('api')
	include = source_node.make_node('include')
	lib_paths = [source_node.make_node('lib')] + [source_node.make_node('lib.%s'%platform) for platform in platform_specific]
	if os.path.isfile(os.path.join(api.abspath(), name.split('.')[-1], 'stdafx.h')):
		pchstop = '%s/%s'%(name.split('.')[-1], 'stdafx.h')
	elif os.path.isfile(os.path.join(include.abspath(), 'stdafx.h')):
		pchstop = 'stdafx.h'
	else:
		pchstop = None

	return bld(
		target = name,
		use = depends,
		features = features,
		defines = ['building_%s' % name.split('.')[-1]],
		export_defines = [],
		includes = [api.path_from(bld.path), include.path_from(bld.path)],
		libs = [],
		lib_paths = lib_paths,
		export_includes = [source_node.make_node('api').path_from(bld.path)],
		frameworks = [],
		source = sources,
		pchstop = pchstop,
		all_sources = all_sources)

@conf
def external(bld, name):
	bld.recurse('src/%s' % name.replace('.', '/'))

@conf
def thirdparty(bld, name, depends=[], libs=[], lib_paths = [], frameworks=[], includes=[], defines=[]):
	m = module(bld, name, depends, ['bugengine_fake_lib'])
	if m:
		m.libs = libs
		m.frameworks = frameworks
		m.export_includes = includes
		m.export_defines = defines
		m.lib_paths += lib_paths
	return m

@conf
def library(bld, name, depends=[], features=[], platforms=[]):
	for f in features:
		if f not in bld.features:
			return None
	return module(bld, name, depends, ['cxx'])

@conf
def static_library(bld, name, depends=[], features=[], platforms=[]):
	for f in features:
		if f not in bld.features:
			return None
	return module(bld, name, depends, ['cxx', 'cxxstlib'])

@conf
def shared_library(bld, name, depends=[], features=[], platforms=[]):
	for f in features:
		if f not in bld.features:
			return None
	return module(bld, name, depends, ['cxx', 'cxxshlib'])

@conf
def engine(bld, name, depends=[], features=[], platforms=[]):
	for f in features:
		if f not in bld.features:
			return None
	return module(bld, name, depends, ['cxx', 'cxxprogram'])

@conf
def game(bld, name, depends=[], features=[], platforms=[]):
	for f in features:
		if f not in bld.features:
			return None
	return module(bld, name, depends, ['cxx', 'cxxshlib', 'plugin', 'game'])

@conf
def plugin(bld, name, depends=[], features=[], platforms=[]):
	for f in features:
		if f not in bld.features:
			return None
	return module(bld, name, depends, ['cxx', 'cxxshlib', 'plugin'])

@feature('plugin')
def plugin_feature(task):
	pass

@feature('game')
def game_feature(task):
	pass

def options(opt):
	opt.bugenginenode = opt.path.parent
	opt.recurse('host')
	opt.recurse('source')
	opt.recurse('target')
	for third_party in opt.path.parent.make_node('src').make_node('3rdparty').listdir():
		opt.recurse('../src/3rdparty/%s'%third_party)

def configure(conf):
	conf.bugenginenode = conf.path.parent
	conf.recurse('checks')
	conf.recurse('host')
	conf.recurse('source')
	conf.recurse('target')

def setup(conf):
	for third_party in conf.bugenginenode.make_node('src').make_node('3rdparty').listdir():
		conf.recurse('../src/3rdparty/%s'%third_party, name='setup', once=False)

def build(bld):
	bld.bugenginenode = bld.path.parent
	if bld.variant == '':
		raise Errors.WafError('Call %s %s %s:toolchain:variant, with toolchain in\n\t%s\nvariant in\n\t%s' %
								(sys.executable, sys.argv[0], bld.cmd, '\n\t'.join(bld.env.ALL_TOOLCHAINS), '\n\t'.join(bld.env.ALL_VARIANTS)))
	bld.platforms = []
	bld.features = []
	bld.bugenginenode = bld.path.parent
	bld.recurse('host')
	bld.recurse('source')
	bld.recurse('target')

def plugins(bld):
	bld.recurse('host')
	bld.recurse('target')



SYSTEM_LIB_PATHS = ['/usr/lib64', '/usr/lib', '/usr/local/lib64', '/usr/local/lib']
lib_patterns = ['lib%s.a', '%s.lib']

@feature('*')
def check_use_taskgens(self):
	"""
	Checks all names in 'use' are valid task generators
	"""
	use = getattr(self, 'use', [])
	for name in use:
		if name not in self.env.ALL_VARIANTS:
			self.bld.get_tgen_by_name(name)

@feature('bugengine_fake_lib')
def process_3rdparty_lib(self):
	"""
	Find the location of a foreign library. Used by :py:class:`waflib.Tools.ccroot.read_shlib` and :py:class:`waflib.Tools.ccroot.read_stlib`.
	"""
	nodes = []

	for name in self.libs:
		node = None
		names = [x % name for x in lib_patterns]
		for x in self.lib_paths + [self.path] + SYSTEM_LIB_PATHS:
			print(x)
			if not isinstance(x, Node.Node):
				x = self.bld.root.find_node(x) or self.path.find_node(x)
				if not x:
					continue
			for y in names:
				node = x.find_node(y)
				if node:
					node.sig = Utils.h_file(node.abspath())
					break
			else:
				continue
			break
		else:
			raise Errors.WafError('%s: could not find library %r' % (self.name, name))
		nodes.append(node)
	self.link_task = self.create_task('fake_stlib', [], nodes)
	self.target = self.name
