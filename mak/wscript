from waflib.Configure import conf
from waflib.TaskGen import feature, extension, before_method, after_method
from waflib import Errors
import os, sys


def module(bld, name, depends, features, use_master, warnings):
	archs = bld.env.VALID_ARCHITECTURES
	platforms = bld.env.VALID_PLATFORMS
	platform_specific = archs + platforms + ['%s.%s'%(p,a) for p in platforms for a in archs]

	extensions = ['cxx', 'cpp', 'cc', 'c', 'rc', 'll', 'yy', 'so', 'dll', 'plist', 'png', 'pkg', 'lua']
	source_node = bld.bugenginenode.make_node('src/%s' % name.replace('.', '/'))
	sources = source_node.ant_glob(['%s/**/*.%s'%(s,ext) for s in ['src', 'bin', 'data'] for ext in extensions])
	sources += source_node.ant_glob(['%s/**/*.script.hh'%s for s in ['api', 'include']])
	all_sources = source_node.ant_glob(['**'])
	api = [i for i in [source_node.make_node('api')] + [source_node.make_node('api.%s'%platform) for platform in platform_specific] if os.path.isdir(i.abspath())]
	include = [i for i in [source_node.make_node('include')] + [source_node.make_node('include.%s'%platform) for platform in platform_specific] if os.path.isdir(i.abspath())]
	lib_paths = [i.path_from(bld.bldnode) for i in [source_node.make_node('lib')] + [source_node.make_node('lib.%s'%platform) for platform in platform_specific] if os.path.isdir(i.abspath())]

	if api and os.path.isfile(os.path.join(api[0].path_from(bld.srcnode), name.split('.')[-1], 'stdafx.h')):
		pchstop = '%s/%s'%(name.split('.')[-1], 'stdafx.h')
	elif include and os.path.isfile(os.path.join(include[0].path_from(bld.srcnode), 'stdafx.h')):
		pchstop = 'stdafx.h'
	else:
		pchstop = None

	if use_master:
		features = features + ['master']
	if warnings:
		uselib = ['warnall', bld.env.VARIANT]
	else:
		uselib = ['warnnone', bld.env.VARIANT]

	if os.path.isdir(os.path.join(source_node.abspath(), 'kernels')):
		kernelspath = source_node.make_node('kernels')
		for kernel in kernelspath.listdir():
			kernelpath = kernelspath.make_node(kernel)
			kernelsources = kernelpath.ant_glob(['**'])
			for toolchain in bld.env.KERNEL_TOOLCHAINS:
				env = bld.all_envs[toolchain]
				bld(
					target = name + '.' + kernel,
					features = ['cxx', 'cxxshlib', 'kernel'],
					uselib = ['warnall', bld.env.VARIANT],
					includes = api+include+['.'],
					source = kernelsources,
					env = env.derive(),
					use = depends + [name],
					install_path = os.path.join('build', bld.env.TOOLCHAIN, bld.env.VARIANT, bld.env.DEPLOY_KERNELDIR))

	return bld(
		target = name,
		use = depends,
		uselib = uselib,
		features = features,
		defines = ['building_%s' % name.split('.')[-1], 'BE_PROJECTID=%s'%name.replace('.', '_'), 'BE_PROJECTNAME=%s'%name],
		export_defines = [],
		includes = api+include+['.'],
		libs = [],
		lib_paths = lib_paths,
		export_includes = api,
		frameworks = [],
		source = sources,
		pchstop = pchstop,
		all_sources = all_sources)

@conf
def external(bld, name):
	bld.recurse(os.path.join(bld.bugenginenode.abspath(), 'src', name.replace('.', '/')))
	return name

@conf
def thirdparty(bld, name, libs=[], lib_paths=[], frameworks=[], includes=[], defines=[], use_master=True, warnings=True):
	archs = bld.env.VALID_ARCHITECTURES
	platforms = bld.env.VALID_PLATFORMS
	platform_specific = archs + platforms + ['%s.%s'%(p,a) for p in platforms for a in archs]
	source_node = bld.bugenginenode.make_node('src/%s' % name.replace('.', '/'))

	lib_paths += [i.path_from(bld.bldnode) for i in [source_node.make_node('lib')] + [source_node.make_node('lib.%s'%platform) for platform in platform_specific] if os.path.isdir(i.abspath())]
	includes += [i for i in [source_node.make_node('api')] + [source_node.make_node('api.%s'%platform) for platform in platform_specific] if os.path.isdir(i.abspath())]

	bld.env['DEFINES_%s' % name] = defines
	bld.env['INCLUDES_%s' % name] = includes
	bld.env['FRAMEWORK_%s' % name] = frameworks
	bld.env['LIBPATH_%s' % name] = lib_paths
	bld.env['LIB_%s' % name] = libs

@conf
def library(bld, name, depends=[], features=[], platforms=[], use_master=True, warnings=True):
	for f in features:
		if f not in bld.features:
			return None
	return module(bld, name, depends, ['cxx', 'cxxobjects'], use_master, warnings)

@conf
def static_library(bld, name, depends=[], features=[], platforms=[], use_master=True, warnings=True):
	for f in features:
		if f not in bld.features:
			return None
	return module(bld, name, depends, ['cxx', 'cxxstlib'], use_master, warnings)

@conf
def shared_library(bld, name, depends=[], features=[], platforms=[], use_master=True, warnings=True):
	for f in features:
		if f not in bld.features:
			return None
	return module(bld, name, depends, ['cxx', 'cxxshlib'], use_master, warnings)

@conf
def engine(bld, name, depends=[], features=[], platforms=[], use_master=True, warnings=True):
	for f in features:
		if f not in bld.features:
			return None
	m = module(bld, name, depends, ['cxx', 'cxxprogram'], use_master, warnings)
	m.install_path = os.path.join('build', bld.env.TOOLCHAIN, bld.env.VARIANT, bld.env.DEPLOY_BINDIR)
	return m

@conf
def game(bld, name, depends=[], features=[], platforms=[], use_master=True, warnings=True):
	for f in features:
		if f not in bld.features:
			return None
	m = module(bld, name, depends, ['cxx', 'cxxshlib', 'plugin', 'game'], use_master, warnings)
	m.install_path = os.path.join('build', bld.env.TOOLCHAIN, bld.env.VARIANT, bld.env.DEPLOY_PLUGINDIR)
	return m

@conf
def plugin(bld, name, depends=[], features=[], platforms=[], use_master=True, warnings=True):
	for f in features:
		if f not in bld.features:
			return None
	m = module(bld, name, depends, ['cxx', 'cxxshlib', 'plugin'], use_master, warnings)
	m.install_path = os.path.join('build', bld.env.TOOLCHAIN, bld.env.VARIANT, bld.env.DEPLOY_PLUGINDIR)
	return m

def options(opt):
	gr = opt.get_option_group('build and install options')
	gr.add_option(	'--nomaster',
					action = 'store_true',
					default = False,
					dest = 'nomaster',
					help = 'build without master files')

	opt.bugenginenode = opt.path.parent
	opt.recurse('host')
	opt.recurse('compiler')
	opt.recurse('source')
	opt.recurse('target')
	for third_party in opt.path.parent.make_node('src').make_node('3rdparty').listdir():
		opt.recurse('../src/3rdparty/%s'%third_party)
	opt.load('visualstudio', tooldir=['mak/tools'])

def configure(conf):
	conf.bugenginenode = conf.path.parent
	conf.recurse('checks')
	conf.recurse('host')
	conf.recurse('compiler')
	conf.recurse('source')
	conf.recurse('target')

def setup(conf):
	for third_party in conf.bugenginenode.make_node('src').make_node('3rdparty').listdir():
		conf.recurse('../src/3rdparty/%s'%third_party, name='setup', once=False)

def build(bld):
	bld.bugenginenode = bld.path.parent
	if bld.variant == '' and not bld.env.PROJECTS:
		raise Errors.WafError('Call %s %s %s:toolchain:variant, with toolchain in\n\t%s\nvariant in\n\t%s' %
								(sys.executable, sys.argv[0], bld.cmd, '\n\t'.join(bld.env.ALL_TOOLCHAINS), '\n\t'.join(bld.env.ALL_VARIANTS)))
	bld.platforms = []
	bld.features = []
	bld.bugenginenode = bld.path.parent
	bld.recurse('host')
	bld.recurse('source')
	bld.recurse('target')

def plugins(bld):
	bld.recurse('host')
	bld.recurse('target')



@feature('*')
def check_use_taskgens(self):
	"""
	Checks all names in 'use' are valid task generators, or move them to uselib
	"""
	use = getattr(self, 'use', [])
	for name in use:
		if name not in self.env.ALL_VARIANTS:
			try:
				y = self.bld.get_tgen_by_name(name)
			except:
				try:
					self.uselib.append(name)
				except AttributeError:
					self.uselib = [name]

@feature('cxx')
def set_building_name_inherits(self):
	seen = set([])
	use = getattr(self, 'use', [])[:]
	while (use):
		x = use.pop()
		try:
			y = self.bld.get_tgen_by_name(x)
		except:
			pass
		else:
			if 'cxxobjects' in y.features:
				use += getattr(y, 'use', [])
				self.env.DEFINES.append('building_%s' % y.target.split('.')[-1])


@feature('plugin')
def plugin_feature(task):
	pass

@feature('game')
def game_feature(task):
	pass

@feature('cxxobjects')
def objects_feature(task):
	pass

@feature('kernel', 'plugin')
@after_method('process_use')
def remove_link_libs(task):
	if not task.env.LINK_WITH_PROGRAM:
		libs = task.env.LIB[:]
		for l in libs:
			try:
				task_gen = task.bld.get_tgen_by_name(l)
				if 'cxxprogram' in task_gen.features:
					task.env.LIB.remove(l)
			except:
				pass

from waflib import Configure, Options, Errors
try:
	import cPickle as pickle
except:
	import pickle

class ConfigurationContext(Configure.ConfigurationContext):
	cmd ='configure'
	def __init__(self, **kw):
		super(ConfigurationContext, self).__init__(**kw)

	def execute(self):
		super(ConfigurationContext, self).execute()
		self.store_options()

	def store_options(self):
		Options.options.path = os.environ['PATH']
		Options.options.include = os.environ.get('INCLUDE', '')
		Options.options.libpath = os.environ.get('LIBPATH', '')
		Options.options.lib = os.environ.get('LIB', '')
		node = self.bldnode.make_node('options.pickle')
		pickle.dump(Options.options, open(node.abspath(), 'wb'), protocol = 2)

from waflib import Configure
class ReconfigurationContext(Configure.ConfigurationContext):
	cmd ='reconfigure'
	def __init__(self, **kw):
		super(ReconfigurationContext, self).__init__(**kw)

	def execute(self):
		self.restore_options()
		super(ReconfigurationContext, self).execute()

	def restore_options(self):
		self.init_dirs()
		try:
			node = self.bldnode.make_node('options.pickle')
			Options.options = pickle.load(open(node.abspath(), 'rb'))
			os.environ['PATH'] = self.environ['PATH'] = Options.options.path
			os.environ['LIBPATH'] = self.environ['LIBPATH'] = Options.options.libpath
			os.environ['LIB'] = self.environ['LIB'] = Options.options.lib
			os.environ['INCLUDE'] = self.environ['INCLUDE'] = Options.options.include

		except IOError:
			raise Errors.WafError('Option file not found; configure the project first')

