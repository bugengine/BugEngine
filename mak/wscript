#set general options for building

import os
import re
from waflib.TaskGen import taskgen_method,feature,before_method,after_method,extension,before
from waflib import Options,Task,Node,Errors
import mak
from mak import module
from waflib.Logs import pprint
from waflib.Tools import ccroot,c,cxx

projects = ['vs2003', 'vs2005', 'vs2005e', 'vs2008', 'vs2008e', 'vs2010', 'vs2010e',
			'xcode3', 'xcode4', 'eclipse', 'netbeans', 'qtcreator']

def options(opt):
	opt.recurse(os.path.join('host', os.name))
	opt.load('visualstudio netbeans xcode eclipse qtcreator', tooldir='mak/tools/IDE')
	#opt.load('parallel_debug', tooldir='mak/waflib/extras')
	for l in 'platforms','archs':
		for target in os.listdir(os.path.join('mak', 'target', l)):
			if target not in ['.svn', '.cvs']:
				opt.recurse(os.path.join('target', l, target))
	if os.path.isdir('extra'):
		for f in os.listdir('extra'):
			if f in ['.svn', '.cvs']:
				continue
			if os.path.isdir(os.path.join('extra', f)) and os.path.isfile(os.path.join('extra', f, 'wscript')):
				opt.recurse(os.path.join('..', 'extra', f))
	gr = opt.get_option_group('build and install options')
	gr.add_option( '--toolchains',
					action='store',
					default='',
					dest='toolchains',
					help='build for the selected toolchains')
	gr.add_option( '--nomaster',
					action='store_true',
					default=False,
					dest='nomaster',
					help='build without master files')
	gr.add_option( '--static',
					action='store_true',
					default=False,
					dest='static',
					help='build a static executable (all plugins built into the engine)')
	for i in os.listdir(os.path.join('src', '3rdparty')):
		if i in ['.svn', '.cvs']:
			continue
		if os.path.isdir(os.path.join('src', '3rdparty', i)):
			opt.recurse(os.path.join('..', 'src', '3rdparty', i))

def configure(conf):
	conf.mak = os.getcwd() + "/mak"
	conf.env['ARCHITECTURES']	= mak.allarchs

	#conf.load('parallel_debug', tooldir='mak/waflib/extras')
	conf.load('visualstudio netbeans xcode eclipse', tooldir='mak/tools/IDE')
	conf.recurse(os.path.join('host', os.name))
	if os.path.isdir('extra'):
		for f in os.listdir('extra'):
			if f in ['.svn', '.cvs']:
				continue
			if os.path.isdir(os.path.join('extra', f)) and os.path.isfile(os.path.join('extra', f, 'wscript')):
				pprint('BLUE', '_'*40)
				pprint('BLUE', '| '+('configure for extra package '+f).ljust(36)+ ' |')
				conf.recurse(os.path.join('..', 'extra', f), once=False)
	for platform in os.listdir(os.path.join('mak', 'target', 'platforms')):
		if platform == conf.env.HOST: continue
		if platform not in ['.svn', '.cvs']:
			pprint('BLUE', '_'*40)
			pprint('BLUE', '| '+('configure for target '+platform).ljust(36)+' |')
			conf.recurse(os.path.join('target', 'platforms', platform))
	pprint('BLUE', '_'*40)
	pprint('BLUE', '| '+('configure for target '+conf.env.HOST).ljust(36)+' |')
	conf.recurse(os.path.join('target', 'platforms', conf.env.HOST))


	if len(conf.env['BUILD_VARIANTS']) == 0:
		raise SystemExit("no match found : make sure you selected a valid toolchain")
	conf.env['DEFAULT_BUILD_TOOL'] = conf.env['BUILD_VARIANTS'][-1]

	selectedvariants = []
	for optim in mak.alloptims:
		for envname in conf.env['BUILD_VARIANTS']:
			name = optim+'-'+envname
			conf.setenv(name, conf.all_envs[envname])
			conf.env['OPTIMISATION'] = optim
			conf.env['PREFIX'] = os.path.join('build', name)
			selectedvariants.append(name)

	conf.variant = ''
	conf.env['BUILD_VARIANTS'] = selectedvariants
	conf.env['ALL_VARIANTS'] = selectedvariants

	if Options.options.toolchains:
		conf.env['SELECTED_TOOLCHAINS'] = Options.options.toolchains
		selectedtoolchains = [re.compile(selected) for selected in conf.env['SELECTED_TOOLCHAINS'].split(',')]
		allvariants = conf.env['BUILD_VARIANTS']
		selectedvariants = []
		for v in allvariants:
			for e in selectedtoolchains:
				if e.match(v):
					pprint('GREEN', 'selected variant %s for build' % v)
					selectedvariants.append(v)
		if not selectedvariants:
			conf.fatal('No toolchain matches the pattern %s, available : %s' % (Options.options.toolchains,str(allvariants)))
	else:
		conf.env['SELECTED_TOOLCHAINS'] = '^debug-'+conf.env['DEFAULT_BUILD_TOOL']+"$"
		pprint('GREEN', 'selected variant %s for build' % str(conf.env['SELECTED_TOOLCHAINS']))
	conf.env.store('.build/be_toolchains.py')
	conf.recurse('libs')

def selectToolchains(ctx):
	if not Options.options.toolchains:
		Options.options.toolchains = ctx.env['SELECTED_TOOLCHAINS']
	selectedtoolchains = [re.compile(selected) for selected in Options.options.toolchains.split(',')]
	selectedvariants = []
	allvariants = ctx.env['BUILD_VARIANTS']
	for v in allvariants:
		for e in selectedtoolchains:
			if e.match(v):
				selectedvariants.append(v)
	ctx.env['BUILD_VARIANTS'] = selectedvariants

def build(bld):
	from waflib import Options
	if bld.__class__.__name__ in projects:
		bld.env.PROJECTS = [bld.__class__.__name__]
	for l in 'platforms','archs':
		for target in os.listdir(os.path.join('mak', 'target', l)):
			if target not in ['.svn', '.cvs']:
				bld.recurse(os.path.join('target', l, target))
	if os.path.isdir('extra'):
		for target in os.listdir(os.path.join('extra')):
			if target not in ['.svn', '.cvs']:
				bld.recurse(os.path.join('..', 'extra', target))
	selectToolchains(bld)
	global builder
	mak.builder = bld
	mak.builder.static = Options.options.static
	bld.m = {}
	for i in os.listdir(os.path.join('src', '3rdparty')):
		if i not in ['.svn', '.cvs']:
			if os.path.isdir(os.path.join('src', '3rdparty', i)):
				bld.recurse(os.path.join('..', 'src', '3rdparty', i), once=False)

def plugins(bld):
	if os.path.isdir('extra'):
		for target in os.listdir(os.path.join('extra')):
			if target not in ['.svn', '.cvs']:
				bld.recurse(os.path.join('..', 'extra', target), name='plugins', once=False)


def clean(ctx):
	selectToolchains(ctx)

def install(ctx):
	selectToolchains(ctx)

def uninstall(ctx):
	selectToolchains(ctx)

@extension('.m')
def m_hook(self, node):
	"""Alias .m files to be compiled the same as .c files, gcc will do the right thing."""
	return self.create_compiled_task('c', node)

@extension('.mm')
def mm_hook(self, node):
	"""Alias .mm files to be compiled the same as .cxx files, gcc will do the right thing."""
	return self.create_compiled_task('cxx', node)

@taskgen_method
@feature('c','cxx')
@before_method('process_source')
def filter_sources(self):
	v = self.env
	self.source = self.to_list(self.source)
	rejectedsources = []
	self.allsources = {}
	for source in self.source:
		head,tail = os.path.split(source)
		while tail:
			head,tail = os.path.split(head)
			if tail[0:5] == 'arch=':
				archs=set(tail[5:].split(','))
				if not v['ARCHITECTURE'] in archs:
					try: self.allsources[tail].append(source)
					except KeyError: self.allsources[tail] = [source]
					rejectedsources.append(source)
					continue
			if tail[0:9] == 'platform=':
				platforms=set(tail[9:].split(','))
				if not set(v['PLATFORM']) & platforms:
					try: self.allsources[tail].append(source)
					except KeyError: self.allsources[tail] = [source]
					rejectedsources.append(source)
					continue
	for src in rejectedsources:
		self.source.remove(src)

@feature('c', 'cxx')
@before_method('apply_incpaths')
@after_method('propagate_uselib_vars')
def private_headers(self):
	self.env.append_value('DEFINES', getattr(self, 'private_defines', []))
	self.env.append_value('INCLUDES', ['.']+getattr(self, 'private_includes', []))

@feature('c', 'cxx')
@after_method("process_source")
def individual_pdb(self):
	if self.env.CC_NAME == 'msvc':
		for t in self.compiled_tasks:
			if t.__class__ == cxx.cxx or t.__class__ == c.c:
				pdb = t.outputs[0].change_ext('.pdb')
				t.env.append_unique('CFLAGS', ['/Fd%s'%pdb.bldpath()])
				t.env.append_unique('CXXFLAGS', ['/Fd%s' % pdb.bldpath()])


@feature('dummy')
def dummy_dummy(self):
	pass
@feature('cobjects')
def dummy_cobjects(self):
	pass




def createmasterfile(task):
	f = open(task.outputs[0].abspath(), 'w')
	for src in task.inputs:
		f.write('#include "%s"\n' % src.path_from(task.generator.bld.path).replace('\\','/'))
	f.close()

MasterTask = Task.task_factory("master", createmasterfile, color='CYAN', before='c cxx')

@taskgen_method
@feature('master')
@before_method('process_source')
@after_method('filter_sources')
@before('c', 'cxx')
def make_masterfiles(self):
	if Options.options.nomaster:
		return
	self.originalsources = self.source[:]
	self.originalsources.sort()
	self.mastertasks = []
	self.source = []
	cmastertask = None
	cppmastertask = None
	cindex	 = 0
	cppindex = 0
	cnumleft = 0
	cppnumleft = 0
	for f in self.originalsources:
		if os.path.splitext(f)[1] not in ['.c', '.C', '.cc', '.cpp', '.cxx', '.hh']:
			self.source.append(f)
			continue
		if os.path.splitext(f)[1] == '.hh':
			self.source.append(f)
			srcnode = self.path.find_resource(f).change_ext('.cc')
		else:
			srcnode = self.path.find_resource(f)
		if os.path.splitext(f)[1] == '.c':
			if cnumleft == 0:
				cnumleft = 30
				masterfile = self.target+'-c-master%d.c' % cindex
				cindex = cindex + 1
				self.source.append(masterfile)
				node = self.path.find_or_declare(masterfile)
				cmastertask = self.create_task("master", [], node)
				self.mastertasks.append(cmastertask)
			cnumleft = cnumleft - 1
			cmastertask.set_inputs(srcnode)
		else:
			if cppnumleft == 0:
				cppnumleft = 30
				masterfile = self.target+'-cpp-master%d.cpp' % cppindex
				cppindex = cppindex + 1
				self.source.append(masterfile)
				node = self.path.find_or_declare(masterfile)
				cppmastertask = self.create_task("master", [], node)
				cppmastertask.set_outputs(node)
				self.mastertasks.append(cppmastertask)
			cppnumleft = cppnumleft - 1
			cppmastertask.set_inputs(srcnode)

objcpydbg = '${OBJCOPY} ${OBJCOPYFLAGS} --only-keep-debug ${SRC[0].abspath()} ${TGT[0].abspath()}'
objcpydbgcls = Task.task_factory('dbg', objcpydbg, 'YELLOW', ext_in='.all', ext_out='.dbg', shell=False)
objcpystrip = '${OBJCOPY} ${OBJCOPYFLAGS} --strip-debug --strip-unneeded --keep-symbol .gnu_debuglink --add-gnu-debuglink ${SRC[0].change_ext(".dbg").path_from(tsk.inputs[0].parent)} ${SRC[0].abspath()} ${TGT[0].abspath()}'
objcpystripcls = Task.task_factory('strip', objcpystrip, 'BLUE', ext_in='.all', shell=False)

@feature('cprogram', 'cxxprogram', 'cshlib', 'cxxshlib')
@after_method('apply_link')
@after_method('apply_implib')
@after_method('apply_implib_program')
def extract_debug_info(self):
	if self.env.CXX_NAME in ['gcc', 'sun'] and self.env.OBJCOPY:
		self.link_task_real = self.link_task
		innode = self.link_task_real.outputs[0]
		outnode = innode.parent.find_or_declare('full').find_or_declare(innode.name)
		debugnode = innode.change_ext('.dbg')
		self.link_task_real.outputs[0] = outnode

		self.link_debug_task = self.create_task('dbg', outnode)
		self.link_debug_task.set_outputs(debugnode)
		self.link_debug_task.set_run_after(self.link_task_real)

		try:
			inst_to = self.install_path
		except AttributeError:
			inst_to = self.link_task.__class__.inst_to
		self.bld.install_files(inst_to, self.link_debug_task.outputs[:], env=self.env)



		self.link_task = self.create_task('strip', outnode)
		self.link_task.set_outputs(innode)
		self.link_task.set_run_after(self.link_debug_task)


@feature('cprogram', 'cxxprogram')
@after_method('apply_link')
@before_method('apply_implib')
def apply_implib_program(self):
	ccroot.apply_implib(self)

from waflib.Build import BuildContext, CleanContext, InstallContext, UninstallContext, ListContext
from waflib import ConfigSet
try:
	env = ConfigSet.ConfigSet('.build/be_toolchains.py')
	for toolchain in env.BUILD_VARIANTS:
		for y in (BuildContext, CleanContext, InstallContext, UninstallContext, ListContext):
			name = y.__name__.replace('Context','').lower()
			class tmp(y):
				cmd = name + '_' + toolchain
				variant = toolchain
except:
	pass

class foo(BuildContext):
	cmd = 'build'
	fun = 'build'
	returned_tasks = []
	def compile(self):
		pass

from waflib import Task
old_sort_tasks = Task.set_file_constraints
def task_priority(t1):
	if t1.__class__.__name__ in ['flex', 'bison', 'datagen']:
		return 'b:'
	elif t1.__class__.__name__ in ['master']:
		return 'a:'
	elif t1.__class__.__name__ == 'cxx':
		f = t1.outputs[0].abspath()
		if f.find('master') != -1:
			return 'f:'+t1.outputs[0].abspath()
		else:
			return 'g:'+t1.outputs[0].abspath()
	elif t1.__class__.__name__ == 'c':
		return 'h:'
	else:
		return 'z:'

def sort_tasks(tasks):
	old_sort_tasks(tasks)
	tasks.sort(key = task_priority)

Task.set_file_constraints = sort_tasks
