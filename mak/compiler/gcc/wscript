from waflib import Utils
from waflib.Configure import conf
import os





def allarchs(arch):
	if arch == 'x86':
		return [(['-m64'], 'amd64'), (['-m32'], 'x86')]
	elif arch == 'amd64':
		return [(['-m32'], 'x86'), (['-m64'], 'amd64')]
	elif arch == 'arm':
		return [([], 'arm')]
	elif arch == 'mips':
		return [(['-m64'], 'mips64'), (['-m32'], 'mips')]
	elif arch == 'mips64':
		return [(['-m32'], 'mips'), (['-m64'], 'mips64')]
	elif arch == 'mipsel':
		return [(['-m64'], 'mipsel64'), (['-m32'], 'mipsel')]
	elif arch == 'mipsel64':
		return [(['-m32'], 'mipsel'), (['-m64'], 'mipsel64')]
	elif arch == 'powerpc' or arch == 'ppc':
		return [(['-m64'], arch+'64'), (['-m32'], arch)]
	elif arch == 'powerpc64' or arch == 'ppc64':
		return [(['-m32'], arch[:-2]), (['-m64'], arch)]
	elif arch == 'spu':
		return [[], 'spu']
	else:
		warn('unknown architecture : %s' % arch)
		return [([], arch)]


@conf
def parse_gcc_target(conf, target):
	for gccname,aname in conf.gcc_architectures:
		if target.find(gccname) != -1:
			return aname


@conf
def get_native_icc_target(conf, icc):
	cmd = [icc, '-V']
	try:
		p = Utils.subprocess.Popen(cmd, stdin=Utils.subprocess.PIPE, stdout=Utils.subprocess.PIPE, stderr=Utils.subprocess.PIPE)
		out = p.communicate()[1]
	except:
		return (None, None)

	if not isinstance(out, str):
		out = out.decode(sys.stdout.encoding)
	out = out.split('\n')
	target = os.uname()[0].lower()
	arch = 'x86'
	version = None
	for line in out:
		words = line.split()
		while len(words):
			if words[0] == 'Intel(R)' and words[1] == '64':
				arch = 'amd64'
			if words[0] == 'ID:':
				if words[1].startswith('m_cproc_'):
					version = words[1][10:].split('.')[0]
			if words[0] == 'Version':
				version = words[1].split('.')[0]
			words = words[1:]
	return (target+'-'+arch, version)


def add_ld_so(conf, filename, paths):
	f = open(file, 'r')
	for line in f:
		line = line.strip()
		if not line:
			continue
		elif line.startswith('#'):
			continue
		elif line.startswith('include'):
			continue
		elif os.path.isdir(line):
			paths.add(line)

@conf
def detect_gcc_archs_from_path(conf, name, libdir, gcc, gxx, version, target, arch):
	bindir = os.path.normpath(os.path.join(libdir, '..', '..', 'bin'))
	versionsmall = '.'.join(version.split('.')[0:2])
	versionverysmall = ''.join(version.split('.')[0:2])

	cc = cxx = None
	for v in ['-%s'%version, '-%s'%versionsmall, '-%s'%versionverysmall, versionverysmall]:
		cc = conf.find_program('%s-%s%s'%(target, gcc, v), var='CC', path_list=[bindir], mandatory=False, silent=True)
		if cc:
			break
	for v in ['-%s'%version, '-%s'%versionsmall, '-%s'%versionverysmall, versionverysmall, '']:
		cxx = conf.find_program('%s-%s%s'%(target, gxx, v), var='CXX', path_list=[bindir], mandatory=False, silent=True)
		if cxx:
			break

	del conf.env['CC']
	del conf.env['CXX']

	if cc and cxx:
		found = False
		for gcc_option, gcc_arch in allarchs(arch):
			cmd = [cc] + gcc_option + ['-dM', '-E', '-']
			p = Utils.subprocess.Popen(cmd, stdin=Utils.subprocess.PIPE, stdout=Utils.subprocess.PIPE, stderr=Utils.subprocess.PIPE)
			p.stdin.write('\n'.encode())
			out = p.communicate()[0]
			if p.returncode != 0:
				continue
			found = True
			conf.env.GCC_TARGETS.append((name, bindir, cc, cxx, version, target, gcc_arch, gcc_option))
		if not found:
			conf.env.GCC_TARGETS.append((name, bindir, cc, cxx, version, target, arch, []))


@conf
def detect_gcc_from_path(conf, path, seen):
	for subdir in ['', 'lib/gcc', 'gcc']:
		libdir = os.path.join(path, subdir)
		if not os.path.isdir(libdir):
			continue
		for target in os.listdir(libdir):
			if not os.path.isdir(os.path.join(libdir, target)):
				continue
			if target in ['.svn', '.cvs']:
				continue
			for version in os.listdir(os.path.join(libdir, target)):
				if not os.path.isdir(os.path.join(libdir, target, version)):
					continue
				if version in ['.svn', '.cvs']:
					continue
				if os.path.islink(os.path.join(libdir, target, version)):
					continue
				if not os.path.isdir(os.path.join(libdir, target, version, 'include')):
					continue
				arch = conf.parse_gcc_target(target) or 'unknown'
				if libdir.find('llvm') != -1:
					gcc, gxx = 'llvm-gcc', 'llvm-g++'
					name = 'llvm'
				else:
					gcc, gxx = 'gcc', 'g++'
					name = 'gcc'
				if (gcc, gxx, version, target, arch) not in seen:
					conf.detect_gcc_archs_from_path(name, libdir, gcc, gxx, version, target, arch)
					seen.append((gcc, gxx, version, target, arch))

@conf
def detect_gcc(conf):
	compilers_gcc_found = []
	conf.env.GCC_TARGETS = []
	bindirs = os.environ['PATH'].split(':')
	paths = [os.path.normpath(os.path.join(path, '..', 'lib')) for path in bindirs]
	paths = set([path for path in paths if os.path.isdir(path)])
	for bindir in bindirs:
		try:
			for f in os.listdir(os.path.join(bindir, '..')):
				libdir = os.path.normpath(os.path.join(bindir, '..', f, 'lib'))
				if os.path.isdir(libdir):
					paths.add(libdir)
		except OSError:
			pass

	if os.path.isfile('/etc/ld.so.conf'):
		add_ld_so(conf, '/etc/ld.so.conf', paths)
	if os.path.isdir('/etc/ld.so.conf.d'):
		for f in os.listdir('/etc/ld.so.conf.d'):
			add_ld_so(conf, '/etc/ld.so.conf.d/'+f, paths)

	for path in paths:
		for lib in os.listdir(path):
			if lib.startswith('gcc'):
				conf.detect_gcc_from_path(os.path.join(path, lib), compilers_gcc_found)
	conf.env.GCC_TARGETS.sort(key= lambda x: (x[2], x[3], x[0]))

@conf
def load_gcc(self, bindir, gcc, gxx, version, target, arch, options):
	self.env.CC = gcc
	self.env.CXX = gxx
	self.load('gcc gxx')

def options(opt):
	pass

def configure(conf):
	archs = getattr(conf, 'gcc_architectures', [])
	conf.gcc_architectures = archs + [
		('i686-w64', 'amd64'),
		('i386', 'x86'),
		('i486', 'x86'),
		('i586', 'x86'),
		('i686', 'x86'),
		('arm-eabi', 'arm'),
		('arm', 'arm'),
		('mipsel', 'mips'),
		('mips', 'mips'),
		('x86_64', 'amd64'),
		('x86', 'x86'),
		('amd64', 'amd64'),
		('powerpc', 'powerpc'),
		('mingw32', 'x86'),
	]

	conf.detect_gcc()

