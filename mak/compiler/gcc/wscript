from waflib import Utils, Logs
from waflib.Configure import conf
import os, sys





def allarchs(arch):
	if arch == 'x86':
		return [(['-m64'], 'amd64'), (['-m32'], 'x86')]
	elif arch == 'amd64':
		return [(['-m32'], 'x86'), (['-m64'], 'amd64')]
	elif arch == 'arm':
		return [([], 'arm')]
	elif arch == 'mips':
		return [(['-m64'], 'mips64'), (['-m32'], 'mips')]
	elif arch == 'mips64':
		return [(['-m32'], 'mips'), (['-m64'], 'mips64')]
	elif arch == 'mipsel':
		return [(['-m64'], 'mipsel64'), (['-m32'], 'mipsel')]
	elif arch == 'mipsel64':
		return [(['-m32'], 'mipsel'), (['-m64'], 'mipsel64')]
	elif arch == 'powerpc' or arch == 'ppc':
		return [(['-m64'], arch+'64'), (['-m32'], arch)]
	elif arch in ['powerpc64', 'ppc64', 'ppu']:
		return [(['-m32'], arch[:-2]), (['-m64'], arch)]
	elif arch == 'spu':
		return [([], 'spu')]
	else:
		Logs.warn('unknown architecture : %s' % arch)
		return [([], arch)]


@conf
def parse_gcc_target(conf, target):
	for gccname,aname in conf.gcc_architectures:
		if target.find(gccname) != -1:
			return aname


@conf
def get_native_icc_target(conf, icc):
	cmd = [icc, '-V']
	try:
		p = Utils.subprocess.Popen(cmd, stdin=Utils.subprocess.PIPE, stdout=Utils.subprocess.PIPE, stderr=Utils.subprocess.PIPE)
		out = p.communicate()[1]
	except:
		return (None, None)

	if not isinstance(out, str):
		out = out.decode(sys.stdout.encoding)
	out = out.split('\n')
	target = os.uname()[0].lower()
	arch = 'x86'
	version = None
	for line in out:
		words = line.split()
		while len(words):
			if words[0] == 'Intel(R)' and words[1] == '64':
				arch = 'amd64'
			if words[0] == 'ID:':
				if words[1].startswith('m_cproc_'):
					version = words[1][10:].split('.')[0]
			if words[0] == 'Version':
				version = words[1].split('.')[0]
			words = words[1:]
	return (target+'-'+arch, version)


def add_ld_so(conf, filename, paths):
	f = open(filename, 'r')
	for line in f:
		line = line.strip()
		if not line:
			continue
		elif line.startswith('#'):
			continue
		elif line.startswith('include'):
			continue
		elif os.path.isdir(line):
			paths.add(line)

@conf
def add_all_archs_to_env(conf, name, bindir, cc, cxx, version, target, arch):
	if cc and cxx:
		found = False
		for gcc_option, gcc_arch in allarchs(arch):
			cmd = [cc] + gcc_option + ['-dM', '-E', '-']
			p = Utils.subprocess.Popen(cmd, stdin=Utils.subprocess.PIPE, stdout=Utils.subprocess.PIPE, stderr=Utils.subprocess.PIPE)
			p.stdin.write('\n'.encode())
			out = p.communicate()[0]
			if p.returncode != 0:
				continue
			found = True
			conf.env.GCC_TARGETS.append((name, bindir, cc, cxx, version, target, gcc_arch, gcc_option))
		if not found:
			conf.env.GCC_TARGETS.append((name, bindir, cc, cxx, version, target, arch, []))


@conf
def detect_gcc_archs_from_path(conf, name, bindir, gcc, gxx, version, target, arch):
	versionsmall = '.'.join(version.split('.')[0:2])
	versionverysmall = ''.join(version.split('.')[0:2])

	cc = cxx = None
	for v in ['-%s'%version, '-%s'%versionsmall, '-%s'%versionverysmall, versionverysmall]:
		cc = conf.find_program('%s-%s%s'%(target, gcc, v), var='CC', path_list=[bindir], mandatory=False)
		if cc:
			break
	for v in ['-%s'%version, '-%s'%versionsmall, '-%s'%versionverysmall, versionverysmall, '']:
		cxx = conf.find_program('%s-%s%s'%(target, gxx, v), var='CXX', path_list=[bindir], mandatory=False)
		if cxx:
			break
	del conf.env['CC']
	del conf.env['CXX']
	conf.add_all_archs_to_env(name, bindir, cc, cxx, version, target, arch)


@conf
def detect_gcc_from_path(conf, path, seen):
	for subdir, relative in [('', '../..'), ('lib/gcc', '../../../..'), ('gcc', '../../..')]:
		libdir = os.path.join(path, subdir)
		if not os.path.isdir(libdir):
			continue
		for target in os.listdir(libdir):
			if not os.path.isdir(os.path.join(libdir, target)):
				continue
			if target in ['.svn', '.cvs']:
				continue
			for version in os.listdir(os.path.join(libdir, target)):
				if not os.path.isdir(os.path.join(libdir, target, version)):
					continue
				if version in ['.svn', '.cvs']:
					continue
				if os.path.islink(os.path.join(libdir, target, version)):
					continue
				arch = conf.parse_gcc_target(target) or 'unknown'
				if libdir.find('llvm') != -1:
					gcc, gxx = 'llvm-gcc', 'llvm-g++'
					name = 'llvm'
				else:
					gcc, gxx = 'gcc', 'g++'
					name = 'gcc'
				bindir = os.path.normpath(os.path.join(libdir, relative, 'bin'))
				if (gcc, gxx, version, target, arch) not in seen:
					conf.detect_gcc_archs_from_path(name, bindir, gcc, gxx, version, target, arch)
					seen.append((gcc, gxx, version, target, arch))

@conf
def get_native_gcc(conf):
	import platform
	if platform.uname()[0].lower() == 'freebsd':
		gcc = '/usr/bin/gcc'
		cmd = [gcc, '-v']
		try:
			p = Utils.subprocess.Popen(cmd, stdin=Utils.subprocess.PIPE, stdout=Utils.subprocess.PIPE, stderr=Utils.subprocess.PIPE)
			out = p.communicate()[1]
		except:
			return (None, None)

		if not isinstance(out, str):
			out = out.decode(sys.stdout.encoding)
		out = out.split('\n')

		arch = None
		platform = None
		version = None

		while out:
			line = out.pop(0)
			if line.startswith('Target: '):
				target = line.split()[1].split('-')
				arch = target[0]
				platform = target[2]
			elif line.startswith('gcc version'):
				version = line.split()[2]
		if arch and platform and version:
			conf.add_all_archs_to_env('gcc', '/usr/bin/', '/usr/bin/gcc', '/usr/bin/g++', version, platform, arch)
		else:
			Logs.warn('could not find native GCC for freebsd')




@conf
def detect_gcc(conf):
	compilers_gcc_found = []
	conf.env.GCC_TARGETS = []
	bindirs = os.environ['PATH'].split(os.pathsep)
	paths = [os.path.normpath(os.path.join(path, '..', 'lib')) for path in bindirs]
	paths = set([path for path in paths if os.path.isdir(path)])
	for bindir in bindirs:
		try:
			for f in os.listdir(os.path.join(bindir, '..')):
				libdir = os.path.normpath(os.path.join(bindir, '..', f, 'lib'))
				if os.path.isdir(libdir):
					paths.add(libdir)
		except OSError:
			pass

	if os.path.isfile('/etc/ld.so.conf'):
		add_ld_so(conf, '/etc/ld.so.conf', paths)
	if os.path.isdir('/etc/ld.so.conf.d'):
		for f in os.listdir('/etc/ld.so.conf.d'):
			add_ld_so(conf, '/etc/ld.so.conf.d/'+f, paths)

	for path in paths:
		for lib in os.listdir(path):
			if lib.startswith('gcc'):
				conf.detect_gcc_from_path(os.path.join(path, lib), compilers_gcc_found)
	conf.get_native_gcc()
	conf.env.GCC_TARGETS.sort(key= lambda x: (x[2], x[3], x[0]))

@conf
def load_gcc(self, bindir, gcc, gxx, version, target, arch, options):
	self.env.CC = gcc
	self.env.CXX = gxx
	self.load('gcc gxx')
	if target.find('mingw') != -1:
		winres = self.find_program(target + '-windres', var='WINRC', path_list=[bindir], mandatory=False)
		if not winres:
			winres = self.find_program('windres', var='WINRC', path_list=[bindir], mandatory=False)
		if not winres:
			winres = self.find_program('windres', var='WINRC', mandatory=False)
		self.load('winres')

def options(opt):
	pass

def configure(conf):
	conf.start_msg('Looking for gcc compilers')
	archs = getattr(conf, 'gcc_architectures', [])
	conf.gcc_architectures = archs + [
		('i686-w64', 'amd64'),
		('i386', 'x86'),
		('i486', 'x86'),
		('i586', 'x86'),
		('i686', 'x86'),
		('arm-eabi', 'arm'),
		('arm', 'arm'),
		('mipsel', 'mips'),
		('mips', 'mips'),
		('x86_64', 'amd64'),
		('x86', 'x86'),
		('amd64', 'amd64'),
		('powerpc', 'powerpc'),
		('mingw32', 'x86'),
		('ppu', 'powerpc'),
		('spu', 'spu')
	]

	conf.detect_gcc()
	conf.end_msg('done')

def build(bld):
	pass
