from waflib.Configure import conf
from waflib.TaskGen import feature, extension, before_method, after_method
import os
from waflib.Tools import c, cxx

c.cshlib.inst_to = ''
cxx.cxxshlib.inst_to = ''

def safe_name(name):
	name = name.replace('-', '_')
	name = name.replace('+', 'x')
	return name

def options(opt):
	opt.add_option('--profile', action='store_true', default=False, dest='profile', help='run WAF in the profiler')
	gr = opt.get_option_group('build and install options')
	gr.add_option(	'--nomaster',
					action = 'store_true',
					default = False,
					dest = 'nomaster',
					help = 'build without master files')
	gr.add_option(	'--static',
					action = 'store_true',
					default = False,
					dest = 'static',
					help = 'build completely static executable: All engine components, plugins, samples and kernels will be built into the executable')
	gr.add_option(	'--dynamic',
					action = 'store_true',
					default = False,
					dest = 'dynamic',
					help = 'build completely dynamic executable: All engine components, plugins, samples and kernels will be built as shared objects')

def module(bld, name, depends, valid_platforms, features, use_master, warnings):
	platforms = bld.env.VALID_PLATFORMS
	build = len(valid_platforms) == 0
	for p in valid_platforms:
		if p in platforms:
			build = True

	source_node = bld.bugenginenode.make_node('src/%s' % name.replace('.', '/'))
	compile_extensions = ['cxx', 'cpp', 'cc', 'c', 'rc', 'm', 'mm']
	preprocess_extensions = ['yy', 'll']
	try:
		sources = source_node.ant_glob(['src/**/*.%s'%(ext) for ext in compile_extensions])
		preprocess_sources = source_node.ant_glob(['src/**/*.%s'%(ext) for ext in preprocess_extensions])
	except OSError:
		sources = []
		preprocess_sources = []
	try:
		preprocess_sources += source_node.ant_glob(['%s/**/*.script.hh'%s for s in ['api', 'include']])
	except OSError:
		pass

	extras = []
	for platform in bld.bugenginenode.make_node('extra').listdir():
		path = os.path.join('extra', platform, '/'.join(name.split('.')))
		if os.path.isdir(path):
			extra_source_node = bld.bugenginenode.make_node(path)
			extras.append((platform, extra_source_node))
			sources += extra_source_node.ant_glob('src/**/*.%s'%ext for ext in compile_extensions)
			preprocess_sources += extra_source_node.ant_glob('src/**/*.%s'%ext for ext in preprocess_extensions + ['script.hh'])

	api = [i for i in [source_node.make_node('api')] if os.path.isdir(i.abspath())]
	include = [i for i in [source_node.make_node('include')] if os.path.isdir(i.abspath())]
	lib_paths = [i.path_from(bld.bldnode) for i in [source_node.make_node('lib')] if os.path.isdir(i.abspath())]

	if api and os.path.isfile(os.path.join(api[0].path_from(bld.srcnode), name.split('.')[-1], 'stdafx.h')):
		pchstop = '%s/%s'%(name.split('.')[-1], 'stdafx.h')
	elif include and os.path.isfile(os.path.join(include[0].path_from(bld.srcnode), 'stdafx.h')):
		pchstop = 'stdafx.h'
	else:
		pchstop = None

	if use_master:
		features = features + ['master']
	if warnings:
		extra_features = ['warnall', bld.__class__.optim]
	else:
		extra_features = ['warnnone', bld.__class__.optim]


	result = []
	sub_envs = [bld.all_envs[envname] for envname in bld.env.SUB_TOOLCHAINS] or [bld.env]
	internal_deps = []

	if build:
		preprocess = bld(name + '.preprocess',
			features= ['plugin'] if 'plugin' in features else [],
			target_name = name,
			pchstop = pchstop,
			source = preprocess_sources)
	else:
		preprocess = None
	for env in sub_envs:
		archs = env.VALID_ARCHITECTURES
		platform_specific = archs + platforms + ['%s.%s'%(p,a) for p in platforms for a in archs]

		platform_api = [i for i in [source_node.make_node('api.%s'%platform) for platform in platform_specific] if os.path.isdir(i.abspath())]
		platform_include = [i for i in [source_node.make_node('include.%s'%platform) for platform in platform_specific] if os.path.isdir(i.abspath())]
		platform_lib_paths = [i for i in [source_node.make_node('lib.%s'%platform) for platform in platform_specific] if os.path.isdir(i.abspath())]

		for platform, extra_source_node in extras:
			if platform in platforms:
				n = extra_source_node.make_node('api')
				if os.path.isdir(n.abspath()):
					api += [n]
				n = extra_source_node.make_node('include')
				if os.path.isdir(n.abspath()):
					include += [n]

		target_prefix = env.ENV_PREFIX or ''
		if build:
			if os.path.isdir(os.path.join(source_node.abspath(), 'kernels')):
				kernelspath = source_node.make_node('kernels')
				for kernel in kernelspath.listdir():
					kernelpath = kernelspath.make_node(kernel)
					kernelsources = kernelpath.ant_glob(['**'])
					for toolchain in bld.env.KERNEL_TOOLCHAINS:
						env = bld.all_envs[toolchain].derive()
						bld(
							target = target_prefix + name + '.' + kernel,
							features = ['cxx', bld.env.STATIC and 'cxxobjects' or 'cxxshlib', 'kernel'],
							extra_use = extra_features,
							defines = ['BE_KERNELID=%s_%s'%(name.replace('.', '_'),kernel), 'BE_KERNELNAME=%s.%s'%(name, kernel)],
							includes = api + platform_api + include + platform_include,
							source = kernelsources,
							env = env.derive(),
							use = [target_prefix + d for d in depends] + [target_prefix + name],
							install_path = os.path.join(bld.env.PREFIX, bld.__class__.optim, env.DEPLOY_KERNELDIR))
		else:
			sources = []
			if 'cxxshlib' in features:
				features.remove('cxxshlib')
			if 'cxxprogram' in features:
				features.remove('cxxprogram')
			if 'cxxstlib' in features:
				features.remove('cxxstlib')
		result.append(bld(
			env = env.derive(),
			target = target_prefix + name,
			target_name = name,
			use = [target_prefix + d for d in depends],
			features = features,
			extra_use = extra_features,
			defines = ['building_%s' % safe_name(name.split('.')[-1]), 'BE_PROJECTID=%s'%name.replace('.', '_'), 'BE_PROJECTNAME=%s'%name],
			export_defines = [],
			includes = api + platform_api + include + platform_include + [bld.bugenginenode],
			libs = [],
			lib_paths = lib_paths,
			export_includes = api + platform_api,
			frameworks = [],
			source = sources[:],
			pchstop = pchstop,
			preprocess = preprocess,
			source_nodes = [source_node] + [e for _, e in extras]))
		if target_prefix:
			internal_deps.append(target_prefix + name)
	if internal_deps:
		bld(target=name, use=internal_deps)
	return result

@conf
def external(bld, name):
	if os.path.isfile(os.path.join(bld.path.abspath(), name.replace('.', '/'), 'wscript')):
		bld.recurse(os.path.join(name.replace('.', '/')))
	else:
		bld.recurse(os.path.join(bld.bugenginenode.abspath(), 'src', name.replace('.', '/')))
	return name

@conf
def thirdparty(bld, name, libs=[], lib_paths=[], frameworks=[], includes=[], defines=[], use_master=True, warnings=True):
	sub_envs = [bld.all_envs[envname] for envname in bld.env.SUB_TOOLCHAINS] or [bld.env]
	for env in sub_envs:
		archs = env.VALID_ARCHITECTURES
		platforms = env.VALID_PLATFORMS
		platform_specific = archs + platforms + ['%s.%s'%(p,a) for p in platforms for a in archs]
		source_node = bld.bugenginenode.make_node('src/%s' % name.replace('.', '/'))

		lib_paths += [i.path_from(bld.bldnode) for i in [source_node.make_node('lib')] + [source_node.make_node('lib.%s'%platform) for platform in platform_specific] if os.path.isdir(i.abspath())]
		bin_paths = [i for i in [source_node.make_node('bin')] + [source_node.make_node('bin.%s'%platform) for platform in platform_specific] if os.path.isdir(i.abspath())]
		includes += [i for i in [source_node.make_node('api')] + [source_node.make_node('api.%s'%platform) for platform in platform_specific] if os.path.isdir(i.abspath())]

		target_name = (env.ENV_PREFIX or '') + name
		env['DEFINES_%s' % target_name] = defines
		env['INCLUDES_%s' % target_name] = includes
		env['FRAMEWORK_%s' % target_name] = frameworks
		env['LIBPATH_%s' % target_name] = lib_paths
		env['LIB_%s' % target_name] = libs
		for bin_path in bin_paths:
			for bin in bin_path.listdir():
				bld.install_as(os.path.join(bld.env.PREFIX, bld.__class__.optim, env.DEPLOY_RUNBINDIR, bin), bin_path.make_node(bin))
	if bld.env.PROJECTS:
		bld(target=name,
			includes=includes,
			defines=defines,
			source_nodes=[source_node])

@conf
def library(bld, name, depends=[], features=[], platforms=[], use_master=True, warnings=True):
	for f in features:
		if f not in bld.features:
			return None
	for p in platforms:
		if p not in bld.env.VALID_PLATFORMS:
			return None
	return module(bld, name, depends, platforms, ['cxx', 'cxxobjects'], use_master, warnings)

@conf
def static_library(bld, name, depends=[], features=[], platforms=[], use_master=True, warnings=True):
	for f in features:
		if f not in bld.features:
			return None
	for p in platforms:
		if p not in bld.env.VALID_PLATFORMS:
			return None
	return module(bld, name, depends, platforms, ['cxx', 'cxxstlib'], use_master, warnings)

@conf
def shared_library(bld, name, depends=[], features=[], platforms=[], use_master=True, warnings=True):
	for f in features:
		if f not in bld.features:
			return None
	for p in platforms:
		if p not in bld.env.VALID_PLATFORMS:
			return None
	return module(bld, name, depends, platforms, ['cxx', 'cxxshlib'], use_master, warnings)

@conf
def engine(bld, name, depends=[], features=[], platforms=[], use_master=True, warnings=True):
	for f in features:
		if f not in bld.features:
			return None
	for p in platforms:
		if p not in bld.env.VALID_PLATFORMS:
			return None
	if bld.env.STATIC:
		m = module(bld, name, depends, platforms, ['cxx', 'cxxobjects'], use_master, warnings)
		bld.launcher_name = name
	else:
		m = module(bld, name, depends, platforms, ['cxx', 'cxxprogram', 'launcher'], use_master, warnings)
		for r in m:
			r.install_path = os.path.join(bld.env.PREFIX, bld.__class__.optim, r.env.DEPLOY_BINDIR)
	return m

@conf
def game(bld, name, depends=[], features=[], platforms=[], use_master=True, warnings=True):
	for f in features:
		if f not in bld.features:
			return None
	for p in platforms:
		if p not in bld.env.VALID_PLATFORMS:
			return None
	m = module(bld, name, depends,platforms,  ['cxx', bld.env.STATIC and 'cxxobjects' or 'cxxshlib', 'plugin', 'game'], use_master, warnings)
	for r in m:
		r.install_path = os.path.join(bld.env.PREFIX, bld.__class__.optim, r.env.DEPLOY_PLUGINDIR)
	return m

@conf
def plugin(bld, name, depends=[], features=[], platforms=[], use_master=True, warnings=True):
	for f in features:
		if f not in bld.features:
			return None
	for p in platforms:
		if p not in bld.env.VALID_PLATFORMS:
			return None
	m = module(bld, name, depends, platforms, ['cxx', bld.env.STATIC and 'cxxobjects' or 'cxxshlib', 'plugin'], use_master, warnings)
	for r in m:
		r.install_path = os.path.join(bld.env.PREFIX, bld.__class__.optim, r.env.DEPLOY_PLUGINDIR)
	return m

def build(bld):
	from waflib import Options
	bld.env.STATIC = bld.env.STATIC or Options.options.static

@feature('*')
def check_use_taskgens(self):
	"""
	Checks all names in 'use' are valid task generators, or move them to uselib
	"""
	use = getattr(self, 'use', [])
	for name in use:
		try:
			y = self.bld.get_tgen_by_name(name)
		except:
			try:
				self.uselib.append(name)
			except AttributeError:
				self.uselib = [name]

@feature('cxx')
def set_building_name_inherits(self):
	seen = set([])
	use = getattr(self, 'use', [])[:]
	while (use):
		x = use.pop()
		try:
			y = self.bld.get_tgen_by_name(x)
		except:
			pass
		else:
			if 'cxxobjects' in y.features:
				use += getattr(y, 'use', [])
				self.env.append_unique('DEFINES', 'building_%s' % y.target.split('.')[-1])


@feature('plugin', 'kernel')
@before_method('apply_link')
@before_method('process_use')
def static_dependencies(self):
	if self.env.STATIC:
		bld = self.bld
		try:
			launcher_tasks = bld.launcher_static
		except AttributeError:
			sub_envs = [bld.all_envs[envname] for envname in bld.env.SUB_TOOLCHAINS] or [bld.env]
			bld.launcher_static = []
			for env in sub_envs:
				target_prefix = env.ENV_PREFIX or ''
				launcher_task = self.bld(env=env.derive(),
										name=target_prefix+bld.launcher_name+'.static',
										target=target_prefix+bld.launcher_name+'.static',
										real_target=target_prefix+bld.launcher_name,
										features=['cxx', 'cxxprogram', 'launcher', 'launcher_static'],
										use = [])
				launcher_task.install_path = os.path.join(self.bld.env.PREFIX, self.bld.__class__.optim, env.DEPLOY_BINDIR)
				bld.launcher_static.append(launcher_task)
			launcher_tasks = bld.launcher_static
		for launcher_task in launcher_tasks:
			launcher_task.use.append(self.target)

@feature('launcher_static')
@before_method('apply_link')
def rename_executable(self):
	self.target = self.real_target


@feature('plugin')
def plugin_feature(task):
	pass

@feature('game')
def game_feature(task):
	pass

@feature('launcher')
def launcher_feature(task):
	pass

@feature('cxxobjects')
def objects_feature(task):
	pass

@feature('kernel', 'plugin')
@after_method('process_use')
def remove_link_libs(task):
	if not task.env.LINK_WITH_PROGRAM:
		libs = task.env.LIB[:]
		for l in libs:
			try:
				task_gen = task.bld.get_tgen_by_name(l)
				if 'cxxprogram' in task_gen.features:
					task.env.LIB.remove(l)
			except:
				pass

@feature('cxx')
def set_extra_flags(self):
	for f in getattr(self, 'extra_use', []):
		self.env.append_unique('CFLAGS', self.env['CFLAGS_%s'%f])
		self.env.append_unique('CXXFLAGS', self.env['CXXFLAGS_%s'%f])
		self.env.append_unique('LINKFLAGS', self.env['LINKFLAGS_%s'%f])

@feature('cxx')
@before_method('filter_sources')
def gather_extra_source(self):
	preprocess = getattr(self, 'preprocess', None)
	if preprocess:
		self.source += getattr(preprocess, 'out_sources', [])
